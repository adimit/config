* Info
This configuration assumes Emacs has been compiled like this:

#+begin_src shell
  make bootstrap && ./autogen.sh && CC=/usr/bin/gcc-10 CXX=/usr/bin/gcc-10 ./configure  --prefix=$HOME/.local/ --with-xwidgets --with-cairo --with-modules --without-compress-install --with-x-toolkit=yes --with-gnutls --without-gconf --without-toolkit-scroll-bars --without-xaw3d --without-gsettings --with-mailutils --with-native-compilation --with-json --with-harfbuzz --with-imagemagick --with-jpeg --with-png --with-rsvg --with-tiff --with-wide-int --without-xft --with-xml2 --with-tree-sitter --with-xpm CFLAGS="-O3 -mtune=native -march=native -fomit-frame-pointer" && make -j8 &&
make install
#+end_src

My current Emacs version is:

GNU Emacs 30.0.50 (build 3, x86_64-pc-linux-gnu, GTK+ Version 3.24.33, cairo version 1.16.0) of 2023-02-08

* Early Initialisation

Everything that is in here needs to happen early.

** Performance
There's a nice [[https://news.ycombinator.com/item?id=39124314][thread on HN]] about optimising Emacs. These are lifted from there.

#+begin_src emacs-lisp
(setq-default bidi-display-reordering 'left-to-right
              bidi-paragraph-direction 'left-to-right
              bidi-inhibit-bpa t)
(setq fast-but-imprecise-scrolling t
      redisplay-skip-fontification-on-input t
      inhibit-compacting-font-caches t)

(setq idle-update-delay 1.0)
#+end_src

Don't do garbage collection in the minibuffer

#+begin_src emacs-lisp
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold (* 32 1024 1024)))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
#+end_src

This is a handy macro to trace execution time. Use like so: ~(aleks/trace "something to trace" 'function-name 2)~. This would trace ~function-name~ whenever it takes longer than 2 seconds to complete (fractional seconds are supported, I think.)

#+begin_src emacs-lisp
(defmacro aleks/trace (msg sym &optional threshold)
  "Trace SYM with MSG, optionally only if duration is over THRESHOLD.

If threshold is non-nil, suppresses the start message to keep things
from getting too noisy."
  `(advice-add
    ,sym :around
    (lambda (orig &rest args)
      (progn
        (unless ,threshold (message "tracing %s" ,msg))
        (let* ((start-time (current-time))
               (result (apply orig args))
               (end-time (float-time (time-subtract (current-time) start-time))))
          (if (or (not ,threshold)
                  (< ,threshold end-time))
              (message "tracing %s took %fs." ,msg end-time))
          result)))))
#+end_src

We don't need the tracing function for garbage collection, as there's a variable for that.

#+begin_src emacs-lisp
#+end_src

** Straight
The initialization code for =straight.el= that lives [[https://github.com/raxod502/straight.el#getting-started][in the straight.el readme]] is already loaded in =init.el=.

Note that you also have to place the following in your =early-init.el=:

#+begin_src emacs-lisp :tangle no
  (setq package-enable-at-startup nil)
#+end_src

** Use-Package

For general package management use use-package, and instruct it to always use straight.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (custom-set-variables
   '(straight-use-package-by-default t))
#+end_src

** Environment

Slurp the shell environment into Emacs when started as a daemon.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :custom exec-path-from-shell-variables
  '("PATH" "MANPATH"))
(when (daemonp)
  (exec-path-from-shell-initialize))
#+end_src

* Emacs

Tweak various aspects of Emacs' visuals and behaviour.

** Appearance & Behaviour

Some basic appearance & behaviour settings

#+begin_src emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
  (set-face-attribute hl-line-face nil :underline nil)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (custom-set-variables
   '(inhibit-startup-screen t)
   ; prevent emacs from trying to resize the frame
   '(frame-inhibit-implied-resize t)
   '(indent-tabs-mode nil)
   '(initial-scratch-message "")
   '(mouse-yank-at-point t))
#+end_src

*** Transparency

I've disabled transparency so far because of two bugs: [[https://github.com/minad/org-modern/discussions/178#discussioncomment-8626220][Blocks in org-modern don't show transparency]], and Prot's =spacious-padding= also doesn't. I think that's a bug in Emacs itself. Once it's fixed (if ever), maybe I'll go back to transparency, because it is kinda nice.

There's a bug report [[https://lists.gnu.org/archive/html/bug-gnu-emacs/2024-05/msg00015.html][on the Emacs bug tracker]]

#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 85))
#+end_src

** Auth
This uses =pass= for all auth storage, including =mu4e= and =ghub=. If there are problems remember =(setq auth-source-debug t).=

#+begin_src emacs-lisp
  (auth-source-pass-enable)
#+end_src

Let Emacs query the pass phrase instead of an external pinentry dialogue.

#+begin_src emacs-lisp
  (customize-set-variable 'epg-pinentry-mode 'loopback)
#+end_src

** Backups

No files with =~= everywhere. Prevent creation of lockfiles, as that confuses some watch tasks (notably webpack dev server.)

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(backup-directory-alist `(("." . "~/.saves")))
 '(delete-old-versions t)
 '(kept-new-versions 6)
 '(kept-old-versions 2)
 '(version-control t)
 '(backup-by-copying t)
 '(make-backup-files t)
 '(create-lockfiles nil))
#+END_SRC

** Calendar
Calendar is set up for European style display (Monday starts week) and manual location of TÃ¼bingen, Germany (for sunrise/sunset).
TÃ¼bingen Hbf is: =48.516738, 9.055493=

#+BEGIN_SRC emacs-lisp
(defvar holiday-baden-wÃ¼rttemberg-holidays
  '((holiday-fixed 1 1 "Neujahr")
    (holiday-fixed 1 6 "Heilige Drei KÃ¶nige")
    (holiday-fixed 5 1 "Tag der Arbeit")
    (holiday-fixed 10 3 "Tag der deutschen Einheit")
    (holiday-fixed 11 1 "Allerheiligen")
    (holiday-fixed 12 25 "Erster Weihnachtsfeiertag")
    (holiday-fixed 12 26 "Zweiter Weihnachtsfeiertag")
    (holiday-easter-etc -2 "Karfreitag")
    (holiday-easter-etc +1 "Ostermontag")
    (holiday-easter-etc +39 "Christi Himmelfahrt")
    (holiday-easter-etc +50 "Pfingstmontag")
    (holiday-easter-etc +60 "Fronleichnam")))


(use-package calendar
  :defer t
  :custom
  (calendar-week-start-day 1)
  (calendar-latitude 48.516738)
  (calendar-longitude 9.055493)
  (calendar-location-name "TÃ¼bingen, Germany")
  (calendar-holidays
   (append holiday-solar-holidays
           holiday-baden-wÃ¼rttemberg-holidays))
  (calendar-date-style 'european)
  (calendar-time-display-form
   '(24-hours ":"
              minutes
              (if time-zone (concat " (" time-zone ")")))))

#+END_SRC

Here's a function that returns whether it's currently dark outside, so you don't have to look.

#+begin_src emacs-lisp
  (defun aleks/is-it-dark-p ()
    "Return t if it's dark outside, otherwise nil.

  Will look at the `current-time' and calculate sunset and sunrise times
  according to `calendar-longitude' and `calendar-latitude' using
  `solar-sunrise-sunset'so make sure you've set your location."
    (require 'solar)
    (let* ((solar (solar-sunrise-sunset (calendar-current-date)))
	 (sunrise (car (car solar)))
	 (sunset (car (car (cdr solar))))
	 (time (decode-time (current-time)))
	 (hour (nth 2 time))
	 (minute (nth 1 time))
	 (minute-fraction (/ minute 60.0))
	 (time-decimal (+ hour minute-fraction)))
    (or (> time-decimal sunset) (< time-decimal sunrise))))
#+end_src

** Emacs-Server

Enable emacs server mode.

#+begin_src emacs-lisp
  (server-mode)
#+end_src

There are two shell aliases that help with server mode:

#+begin_src shell
  alias ec=emacsclient -n
  alias ecc=emacsclient -cn
#+end_src

=ecc= opens another frame, and =ec= just re-uses an existing frame.
** Eshell

A function to open a new shell in the current buffer's file's directory. It's lifted [[https://www.reddit.com/r/emacs/comments/1zkj2d/advanced_usage_of_eshell/][from here]].

#+begin_src emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the current buffer's file."
    (interactive)
    (let* ((parent (file-name-directory (buffer-file-name)))
           (name   (car
                    (last
                     (split-string parent "/" t)))))
      (split-window-vertically)
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))
      (insert (concat "ls"))
      (eshell-send-input)))
#+end_src

** Font

Instead of using a package like =org-variable-pitch-mode=, the
following definition takes care of setting up which parts of
=org-mode= are fixed pitch.

#+begin_src emacs-lisp
(defun aleks/set-org-mode-fixed-pitch-faces ()
  (mapc (lambda (face) (set-face-attribute face nil :family (face-attribute 'fixed-pitch :family)))
        `(org-block
          org-special-keyword
          org-drawer
          org-todo
          org-code
          org-priority
          org-checkbox
          org-block-end-line
          org-block-begin-line
          org-table
          org-verbatim)))
#+end_src

And here's a function to set the different faces.

#+begin_src emacs-lisp
(defun aleks/set-light-mode-faces ()
    "Set the faces for light mode."
    (custom-set-faces
     '(variable-pitch ((t (:family "Bitter" :height 160))))
     '(fixed-pitch ((t (:family "Fira Code" :height 140))))
     '(default ((t (:family "Fira Code" :height 140)))))
    (set-fontset-font "fontset-default" 'symbol '("Iosevka Nerd Font"))
    (set-fontset-font "fontset-default" 'greek-iso8859-7 '("Fira Code Regular")))
#+end_src

We're setting the fontset font for the Greek code page explicitly, because Emacs had trouble finding it and would use some ugly serif font instead. Ideally, this shouldn't be necessary. I think this is a bug, but I've not yet tried reproducing it in a minimal session.

These are triggered after [[Theme]] selection.

** Mime Types

Handle specific file types. This is used especially by =ein-python=.

#+begin_src emacs-lisp
  (custom-set-variables
   '(mailcap-user-mime-data
     '((viewer . "eog %s")
       (type . "image/.*"))))
#+end_src

** Mode Line

Doom's mode line. Not the prettiest thing in the world, but it just works. There's also [[https://github.com/rougier/nano-modeline][nano-modeline]] which I like more, but it doesn't work with LSP ootb, and I can't be bothered to make it work with LSP.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-icon t)
    (doom-modeline-major-mode-icon t)
    (doom-modeline-buffer-state-icon t)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-modal-icon t)
    (doom-modeline-lsp t))

  (use-package nerd-icons
    :if (display-graphic-p))
#+end_src

** Scrolling

This mimics helix editor: scroll one line at a time, leaving some margin at the edges:

#+begin_src emacs-lisp
  (custom-set-variables
   '(mouse-wheel-scroll-amount '(1 ((shift) . 1)))
   '(mouse-wheel-progressive-speed nil)
   '(mouse-wheel-follow-mouse 't)
   '(scroll-step 1)
   '(scroll-margin 6)
   '(scroll-conservatively 101))
#+end_src

The weird thing here is =scroll-conservatively=. It controls how Emacs scrolls once the point moves out of view. The default (0) means that it will always recenter the screen on the point. A value greater than 100 means that it will never do that, and always just try to scoot the buffer so the cursor is visible on the edge.

Since Emacs 29, we've got smooth scrolling, too.

#+begin_src emacs-lisp
  (if (>= emacs-major-version 29)
      (custom-set-variables
       '(pixel-scroll-precision-mode t)
       '(pixel-scroll-precision-large-scroll-height 40.0)
       '(pixel-scroll-precision-interpolation-factor 8.0)))
#+end_src

The interpolation factor dictates scroll speed.

** Search
#+begin_src emacs-lisp
(custom-set-variables
 '(isearch-lazy-count t)
 '(isearch-yank-on-move t))
#+end_src

** Text buffers

When reading and writing text, the buffer shouldn't get too wide. Olivetti mode takes care of that.

Moreover, =text-mode= buffers should have spell check enabled, be narrowed, and use variable pitch and word wrap. However, a variety of buffers seem to trigger =text-mode-hook= that, in my opinion, have no business doing so. So we also define an exclusion list.

#+begin_src emacs-lisp
(defconst not-really-text-modes
  '(yaml-mode nxml-mode mhtml-mode)
  "Modes that somehow trigger the `text-mode-hook' but aren't really text.")

(defun aleks/text-mode-hook ()
  "Set up the current `major-mode' for writing text unless it's a member of `not-really-text-modes'."
  (unless (member major-mode not-really-text-modes)
    (message (format "Setting up %s for writing prose." major-mode))
    (flyspell-mode)
    (visual-line-mode)
    (variable-pitch-mode)
    (olivetti-mode)))

(use-package olivetti
  :hook (text-mode . aleks/text-mode-hook)
  :config
  (set-face-background 'olivetti-fringe (face-attribute 'default :background)))
#+end_src

** Theme

Use Prot's awesome Modus theme, vivendi by default. They're built-in.

#+begin_src emacs-lisp
(load-theme 'modus-vivendi 'no-confirm)
(setq modus-themes-italic-constructs t
          modus-themes-bold-constructs t
          modus-themes-region '(bg-only no-extend)
          modus-themes-scale-headings t
          modus-themes-slanted-constructs t
          modus-themes-scale-1 1.1
          modus-themes-scale-2 1.2
          modus-themes-scale-3 1.3
          modus-themes-scale-4 1.4
          modus-themes-scale-5 1.5)
(add-hook 'org-mode-hook 'aleks/set-org-mode-fixed-pitch-faces)
(add-hook 'prog-mode-hook 'aleks/set-light-mode-faces)
#+end_src

** Undo
We want more generous undo limits, because I make mistakes quite often and I use modern computers.

#+begin_src emacs-lisp
(custom-set-variables
 '(undo-limit (expt 2 24)) ; 16MiB
 '(undo-strong-limit (expt 2 26)) ; 64MiB
 '(undo-outer-limit (expt 2 28))) ; 256MiB
#+end_src

** Utility functions

*** Append to =org-babel-load-languages=

I'd like to append to =org-babel-load-languages= right from a =use-package= =:config= declaration, to keep configuration neat. The following macro loads the Org Babel definition and appends it to =org-babel-load-languages=, instead of overwriting the content of the variable. Accepts a list in the form ='((R . t))=.

#+begin_src emacs-lisp
  (defmacro aleks/org-babel-load-languages (list)
    "Load the language definitions in LIST and add them to `org-babel-load-languages'."
    `(org-babel-do-load-languages
      'org-babel-load-languages
      (append org-babel-load-languages ,list)))
#+end_src

* Major Modes

A list of supported major modes and their configuration.

** CSS
#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css$"
    :custom (css-indent-offset 2))
  (use-package scss-mode
    :mode ("\\.scss$" "\\.sass$"))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :mode "\\.[ct]sv$")
#+END_SRC

** Cucumber
This is useful for ecukes tests. I don't use those myself, but some other packages are covered by ecukes.

#+begin_src emacs-lisp
(use-package feature-mode
  :mode "\\.feature\\'")
#+end_src
** Docker

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode :mode "Dockerfile")
#+END_SRC

** Emacs Lisp
ELisp mode is, of course, built in, but there are some ways to enhance it.

Eros mode shows you the result of elisp expressions in-band, instead of in the mini-buffer. It also has an embark style functionality where you can just inspect the last result which we bind to a useful key.

#+begin_src emacs-lisp
(use-package eros
  :bind (("C-c s i" . eros-inspect-last-result))
  :config
  (eros-mode 1))
#+end_src
** Fish

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode "\\.fish$")
#+END_SRC

** GraphQL

#+BEGIN_SRC emacs-lisp
  (use-package request)

  (use-package graphql-mode
    :load-path "~/src/graphql-mode/"
    :mode "\\.graphql$"
    :custom (graphql-indent-level 2))
#+END_SRC

** Graphviz

Add =graphviz-dot-mode= to facilitate writing of graphviz graphs

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
#+end_src

Also add =ob-dot= to embed graphs in Org mode

#+begin_src emacs-lisp
  (aleks/org-babel-load-languages '((dot . t)))
#+end_src

** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :mode "build\\.gradle" "\\.groovy$")
#+END_SRC

** Haskell

Haskell support via =haskell-mode= and LSP.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.l?hs\\'")

  (use-package lsp-haskell
    :hook
    (haskell-mode . lsp)
    (haskell-literate-mode . lsp))
#+END_SRC

** Json
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json$"
    :config
    (add-to-list 'flycheck-disabled-checkers 'json-python-json))
#+END_SRC

** Kotlin

There's some support via Kotlin's LSP server. It isn't nearly good enough yet, but it gets you most of the way there.

We enable =display-fill-column-indicator-mode= because =ktlint= errors out when the line is too long.

The Kotlin language server likes to eat gigabytes of RAM, so I only activate it manually.

#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode
  :mode "\\.kt$"
  :hook
  ;; (kotlin-mode . lsp)
  (kotlin-mode . display-fill-column-indicator-mode))
#+END_SRC

** Ledger

The function =browse-amazon-history-at-point= is useful to get to the Amazon order number from the bank statement itself. Helps with categorisation.

#+BEGIN_SRC emacs-lisp
  (defun browse-amazon-history-at-point ()
    "Open amazon.de order history.  The search term is `thing-at-point'."
    (interactive)
    (browse-url (concat "https://www.amazon.de/gp/your-account/order-history/?search=" (thing-at-point 'symbol 'no-props))))

  (use-package ledger-mode
    :mode "hledger\\.journal$" "\\.ledger$")

  (use-package flycheck-ledger
    :after flycheck ledger-mode)
#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode "\\.lua$"
    :interpreter "lua")
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md$"
    :custom (markdown-fontify-code-blocks-natively t))
#+END_SRC

** Org
Loading org already happened in =init.el=.

*** Keybindings
#+begin_src emacs-lisp
(use-package org
  :bind (("C-c o a" . org-agenda)
         ("C-c o C" . org-capture)
         ("C-c o c c" . org-capture)
         ("C-c o n" . org-toggle-narrow-to-subtree)
         ("C-c o l" . org-demote-subtree)
         ("C-c o h" . org-promote-subtree)
         ("C-c o c o" . org-clock-out)
         ("C-c o c i" . org-clock-in)
         ("C-c o c g" . org-clock-goto)))
#+end_src

*** Agenda

The most important files get their own variables.

#+begin_src emacs-lisp
  (defcustom org-directory (concat (file-name-as-directory (getenv "HOME")) "org") "Org directory.")
  (defcustom my-org-main-file (concat (file-name-as-directory org-directory) "main.org") "Personal Org agenda file.")
  (defcustom my-org-work-file (concat (file-name-as-directory org-directory) "work.org") "Professional Org agenda file.")
#+end_src

Add diary and agenda files.

#+begin_src emacs-lisp
  (custom-set-variables
   '(org-agenda-include-diary t)
   '(org-agenda-files `(,my-org-main-file ,my-org-work-file))
   '(diary-file (concat (file-name-as-directory org-directory) "diary")))
#+end_src

And here's a plugin to put everything into nice sections, and get a better overview of the agenda

#+begin_src emacs-lisp
  (use-package org-super-agenda
    :hook
    (org-agenda-mode . org-super-agenda-mode)
    :config
    (setq ; this essentially resets `org-super-agenda-header-map' to an empty (pass-through) keymap
     org-super-agenda-header-map (make-sparse-keymap)
     org-super-agenda-groups
     '((:name "Work"
              :file-path "work.org")
       (:name "Meetings"
              :file-path "work.org"
              :todo "MEET")
       (:name "Personal"
              :todo "TODO"
              :tag "family"
              :file-path "main.org"))))
#+end_src

*** Babel

Tangle every block by default.

#+begin_src emacs-lisp
  (add-to-list 'org-babel-default-header-args '(:tangle . "yes"))
#+end_src

Redisplay images after code block evaluation. Handy if the result of your computation is an image: it'll pop up immediately.

#+begin_src emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src

*** Capture

Capture templates:

#+begin_src emacs-lisp
(defun join-lines (strings)
  "Join STRINGS with newlines."
  (string-join strings "\n"))

(customize-set-variable
 'org-capture-templates
 `(("c" "Add to today" entry
    (file+regexp my-org-main-file "Week [0-9][0-9]?")
    ,(join-lines
      '("* TODO %?"
        "SCHEDULED: %t"
        ":PROPERTIES:"
        ":CREATED: %U"
        ":END:"
        "")))
   ("W" "Plan Week" entry (file my-org-main-file)
    ,(join-lines
      '("* Week %(aleks/get-next-week-number)"
        "** TODO Prepare Cat Meds"
        "** TODO Clean Bathroom"
        "** TODO Weekly Review"
        "** TODO Vacuum & Mop"
        "** TODO Make Yogurt"
        "** TODO Feed Sourdough")))
   ("s" "Add task to sprint" entry
    (file+headline my-org-work-file "Tasks")
    ,(join-lines
      '("* TODO %?"
        "SCHEDULED: %t"
        ":PROPERTIES:"
        ":CREATED: %U"
        ":REFERENCE: %f"
        ":END:"
        ""
        "%i")))
   ("j" "Add MP Jira ticket" entry
    (file+headline my-org-work-file "Tasks")
    ,(join-lines
      '("* TODO %(xjira-org-capture-issue \"KNUTH\") %(xjira-get 'issue) %(xjira-get 'title)"
        "SCHEDULED: %t"
        ":PROPERTIES:"
        ":REFERENCE: %(eval (xjira-make-org-link (xjira-get 'issue) (xjira-get 'title)))"
        ":Parent: %(eval (xjira-make-org-link (xjira-get 'parent) (xjira-get 'parent-title)))"
        ":Epic: %(eval (xjira-make-org-link (xjira-get 'epic) (xjira-get 'epic-title)))"
        ":Reporter: %(xjira-get 'reporter)"
        ":END:"
        ""
        "#+begin_quote"
        "%(xjira-get 'description)"
        "#+end_quote")))
   ("M" "Morning routine tasks" entry
    (file+headline my-org-work-file "Tasks")
    ,(join-lines
      '("* TODO Morning Routine on %(calendar-date-string (calendar-current-date))"
        "SCHEDULED: %t"
        ""
        "- [ ] [[https://sentry.io/organizations/meisterplan/issues/][Sentry]]"
        "- [ ] [[https://meisterplan.zendesk.com/agent/dashboard][Support Tickets]]"
        "- [ ] Tests & CVEs")))
   ("m" "Add meeting" entry
    (file+headline my-org-work-file "Meetings")
    ,(join-lines
      '("* MEET %?"
        "SCHEDULED: %^T"
        ":PROPERTIES:"
        ":REFERENCE:"
        ":END:")))
   ("S" "Sprint" entry (file my-org-work-file)
    ,(join-lines
      '("* Sprint %^{Title}"
        "** Meetings"
        "*** MEET EG Backend"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 7) '(10 30))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval eg-backend-confluence-link)"
        ":END:"
        "*** MEET Refinement 1"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 8) '(9 30))"
        "*** MEET Refinement 2"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 10) '(9 30))"
        "*** MEET EG Frontend"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 14) '(10 00))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval eg-frontend-confluence-link)"
        ":END:"
        "*** MEET Refinement 3"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 15) '(9 30))"
        "*** MEET Sprint Review"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-review-day) '(15 30))"
        "*** MEET Retro"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(9 00))"
        "*** MEET Next sprint SP1"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(10 00))"
        "*** MEET Next sprint SP2"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(13 00))"
        "** Tasks"
        "*** TODO Prepare Sprint Start Sheet"
        ":PROPERTIES:"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 3) '(16 00))"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "*** TODO Update Metrics"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/monday-this-week (aleks/next-sprint-review-day)))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "*** TODO Check that metrics are defined"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 16) '(9 00))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "*** TODO Calculate Velocity & Actuals"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 16) '(16 30))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "%i%?")))))
#+end_src

*** Citations

Only works with the new (as of summer 2021) org citation support.
We set the export backend to biblatex for latex.

#+begin_src emacs-lisp
  (custom-set-variables
   '(org-cite-export-processors
     '((latex biblatex)
       (t csl))))
#+end_src

*** Contrib

=org-contrib= is its own repo now, so we need to make it available.

#+begin_src emacs-lisp
  (use-package org-contrib
    :config
    (require 'ox-confluence))
#+end_src

*** Customisation

And we set a lot of configuration options for org.

#+begin_src emacs-lisp
(custom-set-variables
 '(org-tags-column 0) ; alignment broken with variable pitch
 '(org-confirm-babel-evaluate nil) ; don't prompt when evaluating
 '(org-startup-folded t)
 '(org-hide-emphasis-markers t)
 '(org-babel-confirm-evaluate nil)
 '(org-log-into-drawer t)
 '(org-catch-invisible-edits 'show-and-error)
 '(org-special-ctrl-a/e t)
 '(org-log-into-drawer t)
 '(org-ellipsis "â€¦")
 '(org-fontify-whole-heading-line t)
 '(org-pretty-entities t)
 '(org-agenda-tags-column 0)
 '(org-edit-src-content-indentation 0)
 '(org-image-actual-width nil) ; Take the width from ORG_ATTRs
 '(org-outline-path-complete-in-steps nil) ; use a flat list instead of hierarchichal steps
 '(org-refile-targets
   '((nil . (:maxlevel . 4)))) ; don't descend more than 4 levels when refiling
 '(org-footnote-section nil)) ; place footnotes in same section
#+end_src

*** Export

Enable export back ends not enabled by default.

#+begin_src emacs-lisp
  (require 'org)
  (customize-set-variable
   'org-export-backends (append org-export-backends '(md)))
#+end_src

*** Inline Latex

Render inline LaTeX fragments somewhat bigger, to match the font size.
#+begin_src emacs-lisp
  (plist-put org-format-latex-options :scale 2)
#+end_src

*** Hugo
Write blog posts & website with a static site generator, Hugo.

#+begin_src emacs-lisp
(use-package ox-hugo
  :after ox)
#+end_src

*** Reveal

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :custom
    (org-reveal-root "file:///home/aleks/src/talks/reveal.js-4.1.0")
    (org-reveal-hlevel 2))
  (use-package htmlize)
#+END_SRC

*** Visuals

Prettier lists, by substituting bullet points for list item markers.

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 () (compose-region
                    (match-beginning 1)
                    (match-end 1)
                    "â€¢"))))))
#+END_SRC

Org-appear allows easy editing of inline markup when it's hidden.

#+begin_src emacs-lisp
  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autolinks t)
    (org-appear-autosubmarkers t)
    (org-appear-autoemphasis t)
    :straight (org-appear :type git
                :host github
                :repo "awth13/org-appear"))
#+end_src

There's a way to dynamically generate SVGs and inline them in =org= to improve the visuals, but it needs pretty complex configuration that I haven't done yet.

*** Org -Journal

An alternative might be to use =org-roam-dailies= but I saw no benefits so far.

#+begin_src emacs-lisp
(use-package org-journal)
#+end_src
*** Org Modern
A modern look for org mode.

#+begin_src emacs-lisp
(use-package org-modern
  :custom
  (org-modern-replace-stars '("ðŸž´" "ðŸž³" "ðŸž²" "ðŸž±" "ðŸž°"))
  :config
  (global-org-modern-mode)
  (set-face-attribute 'org-modern-done nil :family (face-attribute 'fixed-pitch :family))
  (set-face-background 'fringe (face-attribute 'default :background)))
#+end_src
*** Org Present
A thin presentation mode for org documents. I'll be using this for sprint reviews  and similar occasions.

#+begin_src emacs-lisp
(defun aleks/org-present-enter ()
  "Called by `org-present-mode-hook' to set up presentations."
  (org-present-big)
  (org-display-inline-images)
  (org-present-hide-cursor)
  (org-present-read-only)
  (setq header-line-format " ")
  (org-overview)
  (setq-local face-remapping-alist
              '((default (:height 1.5) variable-pitch)
                (header-line (:height 4.0) variable-pitch)
                (org-document-title (:height 1.75) org-document-title)
                (org-code (:height 1.25) org-code)
                (org-verbatim (:height 1.25) org-verbatim)
                (org-block (:height 1.25) org-block)
                (org-block-begin-line (:height 0.7) org-block))))


(defun aleks/org-present-leave ()
  "Called by `org-present-mode-quit-hook' to roll back all changes to the buffer."
  (org-present-small)
  (org-present-show-cursor)
  (org-present-read-write)
  (setq-local face-remapping-alist '((default variable-pitch default)))
  (setq header-line-format nil))

(use-package org-present
  :commands org-present
  :hook
  (org-present-mode . aleks/org-present-enter)
  (org-present-mode-quit . aleks/org-present-leave))
#+end_src

*** Org-Ref

I'm using org-cite nowadays, but org-ref still has important goodies.

#+begin_src emacs-lisp
(use-package org-ref
  :custom
  (reftex-default-bibliography '("~/doc/lib/bib/main.bib"))
  (org-ref-default-bibliography '("~/doc/lib/bib/main.bib"))
  (org-ref-pdf-directory '("~/doc/lib"))
  (org-ref-insert-cite-function (lambda () (org-cite-insert nil))))
#+end_src

*** Org-Roam


Mostly for lecture notes, ideas for talks, but also random thoughts.

#+begin_src emacs-lisp
  (use-package org-roam
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename (concat (file-name-as-directory (getenv "HOME")) "org/roam")))
    :config
    (org-roam-setup))
#+end_src

And citation integration:

#+begin_src emacs-lisp
(use-package org-roam-bibtex
  :straight
  (:host github :repo "org-roam/org-roam-bibtex")
  :after org-roam
  :hook
  (org-roam-mode . org-roam-bibtex-mode)
  :config
  (require 'org-ref)) ; optional: if using Org-ref v2 or v3 citation links

(use-package citar-org-roam
  :after (citar org-roam)
  :config (citar-org-roam-mode))
#+end_src

Capture templates for roam nodes, and for references.

#+begin_src emacs-lisp
(setq org-roam-capture-templates
      '(("d" "default" plain
         "%?"
         :target
         (file+head
          "%<%Y%m%d%H%M%S>-${slug}.org"
          "#+title: ${note-title}\n")
         :unnarrowed t)
        ("n" "literature note" plain
         "%?"
         :target
         (file+head
          "%(expand-file-name (or citar-org-roam-subdir \"\") org-roam-directory)/${citar-citekey}.org"
          "#+title: ${citar-citekey} (${citar-date}). ${note-title}.\n#+created: %U\n#+last_modified: %U\n\n")
         :unnarrowed t))
      citar-org-roam-capture-template-key "n"
      citar-org-roam-subdir "lit")
#+end_src

**** UI

Not very useful, except as a motivation to have the network grow.

#+begin_src emacs-lisp
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t
            org-roam-ui-open-on-start t))
#+end_src

*** Org-tufte
This is a small package that bundles [[https://edwardtufte.github.io/tufte-css/][Tufte's CSS]] with org mode to make something on the web that resembles [[https://tufte-latex.github.io/tufte-latex/][Tufte's handouts]]. It might come in useful for presentations or blogs, but I'd probably want to modify the CSS a bit.

#+begin_src emacs-lisp
(use-package org-tufte
  :straight
  (org-tufte :type git :host github :repo "Zilong-Li/org-tufte")
  :custom
  (org-tufte-htmlize-code t))
#+end_src

*** Citar

CAPF for bibtex

#+begin_src emacs-lisp
(use-package citar
  :no-require
  :hook
  (LaTeX-mode . citar-capf-setup)
  (org-mode . citar-capf-setup)
  :custom
  (org-cite-insert-processor 'citar)
  (org-cite-follow-processor 'citar)
  (org-cite-activate-processor 'citar)
  (citar-library-paths '("~/doc/lib/"))
  :config
  (add-to-list 'citar-file-open-functions '("pdf" . citar-file-open-external)))

(use-package citar-embark
  :after citar embark
  :no-require
  :config (citar-embark-mode))
#+end_src

** PlantUML

=plantuml-mode= doesn't seem actively developed, but then again, PlantUML isn't exactly the latest and greatest either.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :mode "\\.plantuml\\'"
    :custom
    (plantuml-executable-path "/usr/bin/plantuml")
    (plantuml-default-exec-mode 'executable)
    (org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    :init
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
#+end_src

** Protobuf

For Google's =.proto= spec files

#+begin_src emacs-lisp
  (use-package protobuf-mode)

  (defconst aleks/protobuf-style
    '((c-basic-offset . 2)
      (indent-tabs-mode . nil)))

  (add-hook 'protobuf-mode-hook
    (lambda () (c-add-style "mp-protobuf-style" aleks/protobuf-style t)))
#+end_src

** Python

LSP support with MS's server:

#+begin_src emacs-lisp
  (use-package lsp-python-ms
    :custom (lsp-python-ms-auto-install-server t)
    :hook (python-mode . lsp))
#+end_src

Jupyter notebook support (mainly for org.)

#+begin_src emacs-lisp
  (use-package ein
    :custom
    (ein:output-area-inlined-images t)
    :config
    (aleks/org-babel-load-languages '((ein . t))))
#+end_src

Add =elpy=

#+begin_src emacs-lisp
  (use-package elpy
    :defer t
    :init
    (advice-add 'python-mode :before 'elpy-enable))
#+end_src

** R

#+begin_src emacs-lisp
  (use-package ess
    :config
    (aleks/org-babel-load-languages '((R . t))))
#+end_src

** Racket

Support for the Racket programming language. I used this for AoC.

#+begin_src emacs-lisp
  (use-package racket-mode
    :custom
    (racket-program "/usr/bin/racket")
    :hook
    (racket-mode . racket-xp-mode)
    :custom-face
    (racket-xp-unused-face ((t (:foreground "dark gray" :strike-through nil))))
    :init
    )
#+end_src

** REST

Rest client with org support.

#+begin_src emacs-lisp
  (use-package restclient
    :mode "\\.rest$")

  (use-package ob-restclient
    :after (restclient)
    :config
    (aleks/org-babel-load-languages '((restclient . t))))
#+end_src

** Rust

Rustic mode works well with =rust-analyzer=. Format on save is done with [[Apheleia]] via =rustfmt=.

#+begin_src emacs-lisp
(use-package rustic
  :hook
  (rustic-mode . lsp)
  (rustic-mode . copilot-mode)
  :custom
  (rustic-lsp-server 'rust-analyzer)
  (lsp-rust-server 'rust-analyzer)
  (lsp-rust-analyzer-server-command '("~/.local/bin/rust-analyzer")))
#+end_src

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook (rust-ts-mode . lsp))
#+end_src

** Typescript

Syntax highlighting via newly integrated tree-sitter (Emacs 29).

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescript-ts-mode))
#+end_src

When looking up React functional components, LSP returns React type signatures from React's own definitions in addition to the definition of the component itself. I'm not terribly interested in those, so we filter them out with a crude heuristic (a certain verbatim type signature and file location).

LSP lacks a general entrypoint to filter these out. See [[https://github.com/emacs-lsp/lsp-mode/issues/2103][this issue]].

#+begin_src emacs-lisp
(require 'cl-seq)
(require 'eieio)
(require 'xref)

(defun aleks/xref-react-type-definition-p (item)
  "Return t if `item' is a React type definition."
  (and
   (string-match-p "ReactElement<any, any>" (xref-item-summary item))
   (string-suffix-p "@types/react/index.d.ts" (xref-file-location-file (xref-item-location item)))))

(defun aleks/filter-react-type-definitions (items)
  "Remove React FunctionComponent type definitions from xref-items."
  (cl-remove-if #'aleks/xref-react-type-definition-p items))

(advice-add 'lsp--locations-to-xref-items :filter-return #'aleks/filter-react-type-definitions)
#+end_src

While we're at it, =xref= defaults to popping up a window whenever there's more than one definition it could jump to. That's annoying, I'd prefer it to just use ~completing-read~. We can set ~xref-show-definitions-function~ to achieve that. (This will work in Emacs 28.1 or higher only.) This is most useful in TS because a symbol may at the same time be a value definition and a type name.

#+begin_src emacs-lisp
(setq xref-show-definitions-function #'xref-show-definitions-completing-read)
#+end_src

There's experimental support for inlay hints in typescript language server. I've disabled some inlay hints to improve performance.

#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :mode
  ("\\.ts\\'" . typescript-ts-mode)
  ("\\.tsx\\'" . tsx-ts-mode)
  :init
  (defun aleks/lsp-mode-setup-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless)))
  :hook
  (lsp-completion-mode . aleks/lsp-mode-setup-completion)
  (typescript-ts-mode . lsp)
  (tsx-ts-mode . lsp)
  (typescript-ts-mode . copilot-mode)
  (tsx-ts-mode . copilot-mode)
  :custom
  (lsp-completion-provider :capf)
  (lsp-javascript-display-inlay-hints nil)
  (lsp-javascript-display-enum-member-value-hints nil)
  (lsp-javascript-display-parameter-type-hints nil)
  (lsp-javascript-display-parameter-name-hints nil)
  (lsp-javascript-display-return-type-hints nil)
  (lsp-javascript-display-property-declaration-type-hints nil)
  (lsp-javascript-display-variable-type-hints nil)
  :config
  (defun js-set-inlay-face ()
    (set-face-attribute
     'lsp-javascript-inlay-face nil
     :inherit 'variable-pitch
     :foreground "#787878"
     :height 1.0)))
#+end_src

** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode :mode "\\.ya?ml$")
#+END_SRC

* Utilities

Various add-ons outside of major mode functionality and Emacs core functionality.

** Apheleia (Auto-format on save)
Use [[https://github.com/raxod502/apheleia][Apheleia]] for on-save-actions, e.g. =prettier=, =black=, =rustfmt=.

=rustfmt= isn't supported out of the box. I've opened a [[https://github.com/raxod502/apheleia/pull/45][PR]]. In the meantime, we define our own.

#+begin_src emacs-lisp
(use-package apheleia
  :straight (apheleia :type git
                      :host github
                      :repo "raxod502/apheleia")
  :config
  (apheleia-global-mode +1))
#+end_src

** Avy

Jump to arbitrary points in the buffer

#+begin_src emacs-lisp
(use-package avy
  :custom (avy-all-windows 'all-frames))
#+end_src

** Buttercup
This is just for testing elisp files. Having it in the config allows me to execute the tests from within my active Emacs session, and not just using =eldev=.

#+begin_src emacs-lisp
(use-package buttercup)
#+end_src

** Calculate Sprints

A utility function to calculate the next sprint review's date (usually) from today.

Note that we have to wrap =calendar-day-of-week= even though I've already set =calendar-week-start-day= to =1=, because weekdays are always 0-indexed at Sunday.

#+begin_src emacs-lisp
(require 'calendar)
(require 'cal-dst)
(require 'cal-iso)

(defun aleks/calendar-day-of-week (arg)
  "Get the day of week for ARG, European style.

0 for Monday, â€¦ 6 for Sunday."
  (let ((anglo-day-of-week (calendar-day-of-week arg)))
    (if (= 0 anglo-day-of-week)
        6
      (- anglo-day-of-week 1))))

(defun aleks/get-next-week-number ()
  "Return next week's ISO week number, based on `calendar-current-date'."
  (let* ((monday (aleks/monday-this-week (calendar-current-date)))
         (monday-next-week (+ (calendar-absolute-from-gregorian monday) 7))
         (monday-midnight-next-week (calendar-time-from-absolute monday-next-week 0)))
    (format-time-string "%U"  monday-midnight-next-week t)))

(defun aleks/monday-this-week (&optional origin)
  "Returns the date of the week's monday relative to ORIGIN."
  (let ((start-date (if origin origin (calendar-current-date))))
    (calendar-gregorian-from-absolute
     (- (calendar-absolute-from-gregorian start-date)
        (aleks/calendar-day-of-week start-date)))))

(defun aleks/gregorian-relative-to (offset &optional origin)
  "Add OFFSET days to Monday in the week of ORIGIN (or this week) and return `(MM DD YYYY)'."
  (calendar-gregorian-from-absolute (+ offset (calendar-absolute-from-gregorian (aleks/monday-this-week origin)))))

(defun aleks/next-sprint-review-day (&optional origin)
  "Get the next sprint review (Wednesday in 2 weeks) from ORIGIN or today.

Returns a calendar date '(MM DD YYYY)."
  (calendar-gregorian-from-absolute
   (+ 2 14 (calendar-absolute-from-gregorian (aleks/monday-this-week origin)))))

(defun aleks/next-sprint-planning-day (&optional origin)
  "Get the next day after the sprint review from ORIGIN or today.

Returns a calendar date '(MM DD YYYY)."
  (calendar-gregorian-from-absolute
   (+ 1 (calendar-absolute-from-gregorian
         (aleks/next-sprint-review-day origin)))))

(defun aleks/org-active-timestamp-from-gregorian (date &optional time)
  "Formats an active org-timestamp from DATE and TIME.

DATE is the format of `calendar-current-date' time is a list
'(HH MM) in 24-hour format."
  (let ((seconds (if time
                     (+ (* 60 (nth 1 time)) (* 3600 (car time)))
                   0)))
    (format-time-string
     (if (= seconds 0) "<%Y-%m-%d %a>" "<%Y-%m-%d %a %H:%M>")
     (calendar-time-from-absolute
      (calendar-absolute-from-gregorian date)
      seconds)
     t)))
#+end_src

** Code Review

Rudimentary support for code reviews. Missing line numbers, syntax highlighting. The interface is somewhat clunky, but workable. Integrates with forge and thus magit.

#+begin_src emacs-lisp
  (use-package code-review
    :hook (code-review-mode . emojify-mode)
    :custom (code-review-auth-login-marker 'forge))
#+end_src

** Consult

#+begin_src emacs-lisp
  (use-package consult)
#+end_src

** Company

#+begin_src emacs-lisp
(use-package company
  :config
  (company-tng-mode)
  :hook
  (prog-mode . company-mode)
  :custom
  (company-minimum-prefix-length 2)
  (company-selection-wrap-around t)
  (company-idle-delay 0))

(use-package company-prescient
  :hook (company-mode . company-prescient-mode))

(use-package company-box
  :hook
  (company-mode . company-box-mode))
#+end_src

** Copilot
Github Co-Pilot support. It has no hook, I enable it on an as-need basis. The keychord for accepting completions mimics the one in Fish shell for accepting history items. It's muscle memory, and they look almost the same.

#+begin_src emacs-lisp
(use-package copilot
  :straight (:host github :repo "copilot-emacs/copilot.el" :files ("dist" "*.el"))
  :bind (:map copilot-mode-map
              ("C-f" . 'copilot-accept-completion)
              ("C-M-f" . 'copilot-accept-completion-by-word)))
#+end_src

** Diff-hl

Display git diff hint in the gutter.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :hook (magit-post-refresh . diff-hl-magit-post-refresh)
    :config (global-diff-hl-mode)
    :custom (diff-hl-side 'right))
#+END_SRC

** Dumb Jump
Helps by creating an xref point to jump to for many different languages & language features without needing LSP or a tags file. Needs =rg= to be available (or =ag=, but we're using =rg=).

#+begin_src emacs-lisp
(use-package dumb-jump
  :custom
  (dumb-jump-force-searcher 'rg)
  :config
  (add-to-list 'dumb-jump-project-denoters "node_modules" 'append)
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate))
#+end_src

** Editorconfig

Read =.editorconfig= files and adjust settings correspondingly.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+END_SRC

** Embark

#+begin_src emacs-lisp
  (use-package embark
    :bind (("C--" . embark-act)
           ("C-\\" . embark-dwim)
           ("C-h B" . embark-bindings)))
#+end_src

There's a package that allows using embark commands in consult.

#+begin_src emacs-lisp
  (use-package embark-consult
    :after (embark consult)
    :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Emojis

You know you want it, too. ðŸ˜¼ Using =emojify= mostly for Emoji insertion. Display via Noto Color Emoji font. Enable Emojify mode for github style emojis in Forge Post mode.

#+begin_src emacs-lisp
(set-fontset-font t 'symbol "Noto Color Emoji")
(set-fontset-font t 'symbol "Symbola" nil 'append)

(use-package emojify
  :hook (forge-post-mode . emojify-mode))
#+end_src

** Expand Region

#+begin_src emacs-lisp
(use-package expand-region
  :straight (expand-region
             :host nil
             :branch "treesit-er"
             :repo "/home/aleks/src/expand-region.el")
  :bind (("C-c e" . er/expand-region)))
#+end_src

** Extract Issue Numbers from Branch
Insert the current ticket number if we're on a feature branch.

#+begin_src emacs-lisp
  (defun buffer-insert-at-end (string)
    "Insert STRING at the maximal point in a buffer."
    (save-excursion
      (goto-char (point-max))
      (end-of-line)
      (insert ?\n string)
      (unless (string-suffix-p "\n" string)
        (insert ?\n))))

  (defun get-knuth-number-from-string (string)
    "Return KNUTH issue number from STRING.
  Return nil if STRING does not contain a KNUTH issue.
  STRING may be nil."
    (if (and string (string-match "\\(KNUTH-[[:digit:]]\+\\)" string))
        (match-string 1 string)
      nil))

  (defun insert-knuth-ticket-number-from-branch ()
    "If we're on a KNUTH feature branch, insert the ticket number."
    (interactive)
    (let ((knuth (get-knuth-number-from-string (magit-get-current-branch))))
      (if (and knuth (not (buffer-line-matches-p (concat "^" knuth)))) (buffer-insert-at-end knuth))))

  (defun buffer-line-matches-p (needle)
    "Return t if the last line matches NEEDLE.
  Ignores comments"
    (save-excursion
      (goto-char 0)
      (search-forward-regexp needle nil 'noerror)))

  (add-hook 'git-commit-setup-hook 'insert-knuth-ticket-number-from-branch)
#+end_src

** Flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  ;; setting the load path so flycheck knows about includes
  :custom (flycheck-emacs-lisp-load-path 'inherit)
  :config (global-flycheck-mode))
#+END_SRC

*** Correct dependencies in eldev projects
In order to be able to ~require~ things in Elisp projects using =eldev= and for =flycheck= to pick that up, we'll need this extension.

#+begin_src emacs-lisp
(use-package flycheck-eldev)
#+end_src

*** Checkdoc in org src edit buffers
=checkdoc= will insist on headers, footers, commentary sections etc. in all your elisp code, including code that's opened with =org-src-edit=, which makes no sense at all. The corresponding function is =checkdoc-comments= and it runs whenever =buffer-file-name= is set. Org src edit buffers do set a file name, so =checkdoc= happily checks their comments. There's no way to exclude just one kind of check, so we just disable checkdoc in =org-src-edit= buffers.

#+begin_src emacs-lisp
  (defun disable-checkdoc ()
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
  (add-hook 'org-src-mode-hook 'disable-checkdoc)
#+end_src

** Guess-Language

This guesses the language a text is in per-paragraph. This means that you can code switch in your prose writing without having half the text turn up bright red (and *with* functioning spell-check in all languages.)

#+begin_src emacs-lisp
(use-package guess-language
  :hook (text-mode . (lambda () (guess-language-mode 1)))
  :custom
  (guess-language-languages '(en de bg pl))
  (guess-language-langcodes '((en . ("en_GB" "English"))
                              (de . ("de_DE" "German"))
                              (bg . ("bg_BG" "Bulgarian"))
                              (pl . ("pl_PL" "Polish")))))
#+end_src

** Kagi
For-pay search engine with an API.

#+begin_src emacs-lisp
(use-package password-store)
(use-package shell-maker)
(use-package kagi
  :straight (kagi.el
             :host codeberg
             :repo "bram85/kagi.el")
  :custom
  (kagi-api-token (lambda () (password-store-get "kagi-api")))
  (kagi-summarizer-engine "cecil")
  (kagi-summarizer-default-laungage "EN")
  (kagi-summarizer-cache t))
#+end_src
** LSP

Language Server Protocol support using =lsp-mode=. =read-process-output-max= is set so larger LSP JSON payloads can be processed by Emacs.

#+begin_src emacs-lisp
(use-package lsp-mode
  :hook (lsp-mode . lsp-enable-which-key-integration)
  :custom
  (read-process-output-max (* 5 1024 1024))
  ;(lsp-eslint-validate '("typescript" "svelte"))
  (lsp-rust-analyzer-server-display-inlay-hints t)
  (lsp-eldoc-render-all nil)
  (lsp-use-plists t)
  :bind (("M-RET" . lsp-execute-code-action)
         ("M-d" . lsp-ui-doc-glance)
         ("M-D" . lsp-ui-doc-show))
  :config
  (setq lsp-keymap-prefix "SPC"))
#+end_src

LSP Ui provides action overlays and other goodies, but can get somewhat intrusive.

#+begin_src emacs-lisp
(use-package lsp-ui
  :custom
  (lsp-ui-peek-always-show t)
  (lsp-ui-sideline-enable nil)
  (lsp-ui-doc-enable t)
  :config
  (define-key lsp-ui-peek-mode-map "j" 'lsp-ui-peek--select-next)
  (define-key lsp-ui-peek-mode-map "k" 'lsp-ui-peek--select-prev)
  (define-key lsp-ui-peek-mode-map "J" 'lsp-ui-peek--select-next-file)
  (define-key lsp-ui-peek-mode-map "K" 'lsp-ui-peek--select-prev-file))
#+end_src

Finally, treemacs can help orientation

#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :hook (lsp-mode . lsp-treemacs-sync-mode))
#+end_src

** Magit

The best =git= porcelain ever.

#+begin_src emacs-lisp
(use-package magit
  :bind (("C-c G g" . magit-status)
         ("C-c G G" . magit-status)
         ("C-c G s" . magit-status)
         ("C-c G b" . magit-blame))
  :custom
  (magit-save-repository-buffers 'dontask)
  :config
  (transient-append-suffix 'magit-branch '(2 2 2) '("o" "from current task" aleks/create-branch-from-current-task)))
#+end_src

Integration for Github.

#+begin_src emacs-lisp
  (use-package forge
    :after magit)
#+end_src

*** Integration into org-mode

This allows creating a branch from the currently clocked in org-mode task. Using this alongside my Jira-Bindings allows me to create org-headlines from Jira tickets, clock in, then create a branch for that ticket.

#+begin_src emacs-lisp
  (defun aleks/branchify (string)
    "Make STRING a valid git branch name."
    (replace-regexp-in-string
     (rx (or (any "~" "^" ":" "\\") (seq bos "\.") "\.\." (seq "/" eos) (seq "\.lock" eos)))
     "" (string-replace " " "-" string)))

  (defun aleks/create-branch-from-current-task ()
    "Create a new git branch using the current org task's name."
    (interactive)
    (if (and (boundp 'org-clock-current-task) org-clock-current-task)
        (let ((branch-name (aleks/branchify org-clock-current-task)))
          (magit-branch-and-checkout branch-name (magit-read-starting-point "Create and checkout branch starting at"))
          (message "Created and checked out `%s'" branch-name))
      (message "No current task.")))
#+end_src

** Meow
The heart of the editing experience. This is an alternative to =evil=, it allows for modal editing with an automatic moving selection, like in Helix or Kakoune.

I aim to keep my config here relatively consistent with Helix. It diverges from there only where I can't or haven't yet found a way to make it work. (Or where I don't care, because I don't use that particular functionality. As a rule of thumb, that includes everything that =Alt= is used for in Helix, as I don't use =Alt= while editing.)

In particular, multiple cursors don't work the same way as in Helix. Emacs' editing model is not very conducive to multiple cursors, they're hard to make work in general.

*** TODO Add skip paragraph/defun bindings ={= and =}=
*** TODO Add surround objects for quotes and org/markdown markup
=``=, =""=, =''=, =**=, etc. Actually, a functionality like in Helix where you can just use arbitrary characters as surrounds would be great, but I think that's going to be a bit difficult with Meow.
*** TODO Stop windows from bouncing around when opening transients
The documentation of =transient-display-buffer-action= should help with that. Pity there are no examples.

A different option would be to stop using transients altogether. Meow uses something for its surround functions that might be useful.
*** TODO Join lines easily
In Helix and Vim you can use =J= (they work slightly differently, we're using the Helix way here). Meow uses the Kakoune-style capital keybindings for extending selections across lines. In order to use =J= for joining lines, we'll need to also add a visual mode to Meow.
*** TODO Make =xa= behave the same way as in Helix
In =hx= you would start on the next line, in Meow you start on the same line. This is low priority, as I actually kinda like Meow's behaviour more.
*** DONE Create =ga= and =gm= like in Helix
Go to last accessed file, goto last modified file. We'll leave =gm= be for now.
*** DONE Create paste bindings for  =p= and =P=
Meow's default (~meow-yank~) is much like Vim/Helix's =P=, but if you've got a whole line in the kill ring, it'll paste it in the middle of your cursor. That's not great, and very confusing.
We also still need the default action, append-paste (yank, whatever), i.e. paste below, or after the current cursor.

#+begin_src emacs-lisp
(defun aleks/pasting-line-p ()
  "Returns t if `kill-ring' ends with a newline."
  (string-suffix-p "\n" (car kill-ring)))

(defun aleks/paste-above ()
  "Like Vim's `P'."
  (interactive)
  (when (aleks/pasting-line-p)
    (beginning-of-line))
  (call-interactively 'meow-yank))

(defun aleks/paste-below ()
  "Like Vim's `p'."
  (interactive)
  (if (aleks/pasting-line-p)
      (progn (end-of-line)
             (let* ((transform (lambda (str) (concat "\n" (substring str 0 -1))))
                    (yank-transform-functions `(,transform ,@yank-transform-functions)))
               (call-interactively 'meow-yank)))
    (progn (forward-char)
           (call-interactively 'meow-yank))))
#+end_src

*** DONE =e= should not select newline when it's the last word
I'm not sure that it does. But =ed= should *not* delete the newline, just the last word.

In fact, =(buffer-substring (mark) (point))= says that the newline isn't part of it. So the behaviour is actually =d=.

The actual problem was =aleks/delete=. I don't actually know why I had that ~(when (looking-at "\n"))~ clause.
*** TODO Make =w= behave more like in Helix/Vim
I'll need to find the exact boundaries at which the cursor stops.

This is a pretty big task: Emacs doesn't have what we need, its ~forward-word~ is written in C (no doubt for efficiency reasons) and it has a very different idea of what a word is than we do.

But there's a mechanism to hack into ~forward-word~ called ~find-word-boundary-function-table~. Setting it locally here, just as we do in the yank step might be useful. Unfortunately, the documentation for ~find-word-boundary-function-table~ is utterly useless. I think I get how it's supposed to work, but it's intransparent which characters correspond to which point in the array. I guess I'll have to read the C source code.

In order to find out *how* to override it, studying Helix' code could come in handy. See =src/core/movement.rs=, line 237. We'll need to find out what ~range_to_target~ does for the different targets. For moving to word ends, the targets are ~WordmotionTarget::NextWordEnd~ and ~WordMotionTarget::NextLongWordEnd~.

Helix goes through all the chars in its range and categorises them according to ~categorize_char()~ in ~char.rs~ into EOL, newline, word, punctuation or "unknown". It uses these categories to detect word boundaries in ~is_word_boundary()~ and ~is_long_word_boundary()~ in ~movement.rs~. see ~reached_target()~ right after for some additional conditions for the different movement types.

#+begin_src emacs-lisp
(defun aleks/move-forward-word ()
  "Move forward one word."
  (interactive))
#+end_src
*** TODO Add proper bindings in magit
- [ ] have to remap =SPC= somehow.
- [ ] ~discard-hunk~ needs a proper binding
- [ ] search needs to work properly
- [ ] select needs to work properly (visual mode needs to work for that)
*** TODO Add proper bindings for org agenda
*** TODO Rebind meow's keypad key
Space would be much better suited for a general menu
*** TODO Create space menu
*** DONE Accept =(= =)=, and ={= =}= etc for selections
To change generics tags in languages like TS, Rust, or HTML or JSX tags, we register =angle=

#+begin_src emacs-lisp
(with-eval-after-load 'meow
  (meow-thing-register 'angle '(pair ("<") (">")) '(pair ("<") (">")))
  (meow-thing-register 'single-quote '(pair ("'") ("'")) '(pair ("'") ("'")))
  (meow-thing-register 'double-quote '(pair ("\"") ("\"")) '(pair ("\"") ("\"")))
  (meow-thing-register 'backtick '(pair ("`") ("`")) '(pair ("`") ("`")))
  (meow-thing-register 'org-verb '(pair ("=") ("=")) '(pair ("=") ("=")))
  (meow-thing-register 'org-code '(pair ("~") ("~")) '(pair ("~") ("~"))))
#+end_src

Meow uses /round/, /square/, /curly/ etc. but I find that unintuitive.

#+begin_src emacs-lisp
(with-eval-after-load 'meow
  (setq meow-char-thing-table
        `(,@meow-char-thing-table
          (?\( . round)
          (?\) . round)
          (?\[ . square)
          (?\] . square)
          (?{ . curly)
          (?} . curly)
          (?< . angle)
          (?> . angle)
          (?' . single-quote)
          (?\" . double-quote)
          (?` . backtick)
          (?= . org-verb)
          (?~ . org-code))))
#+end_src

*** DONE Make =F= and =T= work as expected
Meow's idea to use =-f= is cute, but =F= is in muscle memory, and free anyway.

#+begin_src emacs-lisp
(defun aleks/meow-find-backwards ()
  "Like `meow-find', but backwards."
  (interactive)
  (let ((current-prefix-arg -1))
    (call-interactively 'meow-find)))


(defun aleks/meow-till-backwards ()
  "Like `meow-till', but backwards."
  (interactive)
  (let ((current-prefix-arg -1))
    (call-interactively 'meow-till)))
#+end_src

*** DONE Make =C= , =D=, =Y= work as expected
Note that =C-k= is =org-kill-line= in org-mode. These bindings have to respect that.

- [X] =C=: kill to the end of the line, then insert-mode
- [X] Make =C= respect =org-kill-line= in =org-mode=
- [X] =D=: kill to the end of the line
- [X] =Y=: copy until the end of the line
- [X] unbind =s=, we don't need it (maybe it'll come in handy for something else)

Meow has a selection fallback mode: certain commands work without a selection. When they're called with no selection, a certain other action is invoked instead. These fallbacks are registered in ~meow-selection-command-fallback~.

We could either register our command in said variable, or we can just fake ~this-command~ which ~meow--with-selection-fallback~ uses to determine the fallback.

#+begin_src emacs-lisp
(defun aleks/change-line ()
  "Kill the rest of the line, then drop into insert mode."
  (interactive)
  (setq this-command #'meow-kill)
  (call-interactively 'meow-kill)
  (meow--switch-state 'insert)
  (setq-local meow--insert-pos (point)))
#+end_src

The copy-to-the-end-of-line function only does so if the selection is empty, and otherwise copies the selection.

#+begin_src emacs-lisp
(defun aleks/Y ()
  "Copy the region from point to end of line."
  (interactive)
  (if (region-active-p)
      (call-interactively 'copy-region-as-kill)
    (copy-region-as-kill (point) (line-end-position))))
#+end_src
*** TODO Create a visual mode for Meow
[[https://github.com/meow-edit/meow/blob/master/CUSTOMIZATIONS.org#meow-define-state][There's docs on how to define a custom state]], those might help.
Defining a visual mode frees up several important keybindings like =H= =L= =J= and =K=.

#+begin_src fundamental
(defvar aleks/meow-visual-keymap (make-keymap))
(meow-define-state visual
  "moew state emulating Vim/Helix visual state."
  :lighter " [V]"
  :keymap aleks/meow-visual-keymap
  (if (eq meow--currrent-state 'visual)
      (meow-select)))

(setq meow-cursor-type-visual 'block)

(meow-define-keys 'visual
  '("<escape>" . meow-normal-mode)
  '("h" . meow-left-expand)
  '("l" . meow-right-expand)
  '("j" . meow-next-expand)
  '("k" . meow-prev-expand)
  '("w" . meow-next-expand)
  '("b" . meow-back-word))

(add-variable-watcher 'meow--currrent-state
                      (lambda (sym val op where)
                        (message "meow--currrent-state: %s" val)))

(add-variable-watcher 'meow--selection
                      (lambda (sym val op where)
                        (message "meow--selection: %s" val)))
#+end_src
*** DONE Preserve C-W in insert mode

I don't use control a lot in insert mode, but =C-w= is important to my mental well-being. We'll need to tell Meow that we don't want =C-w= to do anything with regions later by setting =meow--kbd-kill-region= to =S-<delete>=.

#+begin_src emacs-lisp
(defun aleks/delete-backward-word ()
  "Delete previous word. This is a copy of `evil-delete-backward-word'"
  (interactive)
  (let ((beginning (save-excursion
                     (call-interactively 'backward-word)
                     (point)))
        (end (point)))
    (cond
     ((not (bobp)) (delete-region
                    (max beginning (line-beginning-position))
                    end))
     (t (user-error "Beginning of line or buffer.")))))
#+end_src

*** DONE Fix delete keybinding
Meow's default is terrible. It should work like in Helix. We can't just use =kill-region=, because that, rather annoyingly, doesn't end up deleting newlines.

#+begin_src emacs-lisp
(defun aleks/delete ()
  "Deletes a character or the selection, if there is an active region."
  (interactive)
  (if (region-active-p)
      (progn
        (call-interactively 'kill-region))
    (call-interactively 'meow-delete)))
#+end_src

*** DONE Surround

Helix has a small surround menu that pops up with =m= in normal mode. We'll try something similar here.

First, we'll need to define all the functions that'll do the heavy lifting for find and replacing surrounding objects.

#+begin_src emacs-lisp
(defvar aleks/list-of-mirrored-things
  '((?\( . ?\))
    (?\[ . ?\])
    (?{ . ?})
    (?< . ?>))
  "A list of tuples for characters that should be mirrored when manipulating selections.")

(defun aleks/find-mirrored-pair (char)
  "If CHAR is a known mirrored pair, return it, or two copies of CHAR."
  (or (assoc char aleks/list-of-mirrored-things)
      (rassoc char aleks/list-of-mirrored-things)
      `(,char . ,char)))

(defun aleks/get-ordered-selection ()
  "Return the points at which to insert a surround.

It's either the beginning and end of a region, if such
is active, or the value of `point' and one to the right of it."
  (if (region-active-p)
      `(,(region-beginning) . ,(region-end))
    `(,(point) . ,(+ (point) 1))))

(defun aleks/insert-surround ()
  "Insert a pair of delineators around the selection."
  (interactive)
  (let ((target (aleks/find-mirrored-pair (read-char "Insert around selection:")))
        (reg (aleks/get-ordered-selection)))
    (save-excursion
      (goto-char (cdr reg))
      (insert (cdr target))
      (goto-char (car reg))
      (insert (car target)))
    (message (format "Inserting %c %c around selection." (car target) (cdr target)))))

(defun aleks/replace-surround ()
  "Replaces a pair of delineators around the selection. NYI"
  (interactive)
  (save-excursion
    (let* ((target (aleks/find-mirrored-pair (read-char "Replace char:")))
           (a (search-backward (char-to-string (car target)) nil t))
           (b (search-forward (char-to-string (cdr target)) nil t)))
      (if (and a b)
          (let ((replacement (aleks/find-mirrored-pair (read-char "Replace with:"))))
            (goto-char a)
            (delete-char 1)
            (insert (car replacement))
            (goto-char b)
            (left-char)
            (delete-char 1)
            (insert (cdr replacement)))))))

(defun aleks/delete-surround ()
  "Deletes a pair of delineators around the selection. NYI"
  (interactive)
  (save-excursion
    (let* ((target (aleks/find-mirrored-pair (read-char "Delete char:")))
           (a (search-backward (char-to-string (car target)) nil t))
           (b (search-forward (char-to-string (cdr target)) nil t)))
      (if (and a b)
          (progn
            (goto-char a)
            (delete-char 1)
            (goto-char b)
            (left-char 2)
            (delete-char 1))))))

(defun match-paren (arg)
  "Go to the matching paren if on a paren; otherwise insert %."
  (interactive "p")
  (cond ((looking-at "\\s(") (forward-list 1) (backward-char 1))
        ((looking-at "\\s)") (forward-char 1) (backward-list 1))))
#+end_src

Then, we can assign them to a transient.

#+begin_src emacs-lisp
(require 'transient)
(transient-define-prefix dispatch-surround-menu () "This isn't documentation"
  [[("m" "go to matching bracketish" match-paren)
    ("s" "surround add" aleks/insert-surround)
    ("r" "surround replace" aleks/replace-surround)
    ("d" "surround delete" aleks/delete-surround)
    ("a" "select around object" meow-bounds-of-thing)
    ("i" "select inside object" meow-inner-of-thing)]])
#+end_src

*** DONE Append
In Vim & Helix, pressing =A= will move the cursor to the end of the line, then drop you into insert mode. Meow doesn't know how that works.

#+begin_src emacs-lisp
(defun aleks/append-line ()
  "Append to the end of the line"
  (interactive)
  (when (region-active-p)
    (meow-cancel-selection))
  (end-of-line)
  (meow--switch-state 'insert))
#+end_src

*** DONE Transient Window

Rather annoyingly, =window.el= defines ~split-window-vertically~ and ~split-window-horizontally~ the wrong way around, causing all manner of confusion. (If you split a window vertically, you split it *down*, with a window on the left side, then the right side! But =window.el= states: "Split WINDOW-TO-SPLIT into two windows, _one above the other_.") So we need to swap directions here.

#+begin_src emacs-lisp
(transient-define-prefix dispatch-window-menu () "This isn't documentation"
  [["Movement"
    ("h" "left" windmove-left)
    ("l" "right" windmove-right)
    ("k" "up" windmove-up)
    ("j" "down" windmove-down)]
   ["Control"
    ("c" "delete this window" delete-window)
    ("o" "delete other windows" delete-other-windows)
    ("-" "split window horizontally" split-window-vertically)
    ("v" "split window vertically" split-window-horizontally)]
   ["Winner"
    ("u" "winner mode undo" winner-undo)
    ("r" "winner mode redo" winner-redo)]])
#+end_src

*** DONE Transient GoTo menu
This menu opens when you  press =g=. It's similar to Helix' menu, but not quite the same.

#+begin_src emacs-lisp
(defun aleks/goto-line (&optional count)
        "Jump to COUNT line, or to the end of the buffer."
        (interactive "p")
        (if (null current-prefix-arg)
            (call-interactively 'end-of-buffer)
          (call-interactively 'goto-line)))
#+end_src

#+begin_src emacs-lisp
(transient-define-prefix dispatch-goto-menu () "This isn't documentation"
  [["Move"
    ("e" "bottom" end-of-buffer)
    ("g" "top" beginning-of-buffer)
    ("d" "definition (xref)" xref-find-definitions)
    ("h" "beginning of line" beginning-of-line)
    ("l" "end of line" end-of-line)
    ("s" "first non-blank-line" beginning-of-line-text)]
   ["Buffer"
    ("n" "next buffer" next-buffer)
    ("p" "previous buffer" previous-buffer)
    ("b" "bury buffer" bury-buffer)
    ("u" "unbury buffer" unbury-buffer)
    "Avy"
    ("c" "goto char" avy-goto-char)
    ("L" "got line" avy-goto-line)]
   ["LSP"
    ("r" "references" lsp-ui-peek-find-references)
    "Files"
    ("f" "file at point" find-file-at-point)
    ("a" "last file" pop-global-mark)]])
#+end_src

*** Setup
#+begin_src emacs-lisp
(defun meow-setup ()
  "My meow setup"
  (meow-motion-overwrite-define-key
   '("j" . meow-next)
   '("k" . meow-prev)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; SPC j/k will run the original command in MOTION state.
   '("j" . "H-j")
   '("k" . "H-k")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("a" . meow-append)
   '("A" . aleks/append-line)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("C" . aleks/kill-line)
   '("c" . meow-change)
   '("d" . aleks/delete)
   '("D" . meow-kill)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("F" . aleks/meow-find-backwards)
   '("g" . dispatch-goto-menu)
   '("G" . end-of-buffer)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . dispatch-surround-menu)
   '("n" . meow-search)
   '("o" . meow-open-below)
   '("O" . meow-open-above)
   '("P" . aleks/paste-above)
   '("p" . aleks/paste-below)

   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("t" . meow-till)
   '("T" . aleks/meow-till-backwards)
   '("u" . meow-undo)
   '("U" . undo-redo)
   '("v" . meow-visit)
   '("w" . meow-next-symbol)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . aleks/Y)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("/" . isearch-forward)
   '("?" . isearch-backward)
   '("=" . meow-indent)
   '("<return>" . save-buffer)
   '("<escape>" . meow-cancel-selection)
   '("C-w" . dispatch-window-menu)
   '("C-f" . scroll-up-command)
   '("C-b" . scroll-down-command)))
(use-package meow
  :demand t
  :bind
  (("C-w" . aleks/delete-backward-word)
   ("C-c b b" . switch-to-buffer)
   ("C-c b k" . kill-buffer)
   ("C-c x u" . undo-only)
   ("C-c w" . dispatch-window-menu))
  :custom
  (meow-cheatsheet-layout meow-cheatsheet-layout-dvorak)
  :config
  (setq meow--kbd-kill-region "S-<delete>"
        meow--kbd-forward-char "<right>"
        meow--kbd-backward-char "<left>"
        meow--kbd-undo "C-c x u")

  (meow-setup)
  (meow-global-mode 1))
#+end_src

** Move File and Buffer
Adapted from this [[https://stackoverflow.com/questions/384284/how-do-i-rename-an-open-file-in-emacs][StackOverflow answer]]. This lets you rename the current buffer and file at the same time.

#+begin_src emacs-lisp
(defun rename-file-and-buffer ()
  "Renames both current buffer and file it's visiting.

It's just an alias now to the built-in `rename-visited-file'."
  (interactive)
  (rename-visited-file))
#+end_src

** Mu4e

The context definitions are in =private.org=.

=set-from-line= manages identities: always answer with the =to:= email address when it's to one of my private email addresses. Manage mailing list identities separately (I know of no automatic way, unfortunately.)

#+begin_src emacs-lisp
(defun aleks/set-from-line ()
  "Set From: address based on To: address of original email.  Also set mailing list addresses."
  (when mu4e-compose-parent-message
    (cond
     ((mu4e-message-contact-field-matches mu4e-compose-parent-message :to "aleks.bg")
      (setq user-mail-address (plist-get (car (mu4e-message-field mu4e-compose-parent-message :to)) :email)))
     ((mu4e-message-contact-field-matches mu4e-compose-parent-message :list-post "emacs-orgmode")

      (setq user-mail-address "org@list.aleks.bg")))))

(defun aleks/sequence-to-directory (&rest args)
  "Turn ARGS into a valid path, each item a segment."
  (mapconcat #'file-name-as-directory args nil))

(use-package mu4e
  :commands mu4e
  :straight (:host github
                   :files ("build/mu4e/*.el")
                   :repo "djcb/mu"
                   :pre-build (("meson" "build") ("ninja" "-C" "build")))
  :config
  (require 'mu4e-contrib)
  (aleks/load-org-file "private.org")
  (add-to-list 'mu4e-headers-actions '("in browser" . mu4e-action-view-in-browser) t)
  (add-to-list 'mu4e-view-actions '("in browser" . mu4e-action-view-in-browser) t)
  (require 'org-mu4e)
  :hook
  (mu4e-view-mode . aleks/disable-show-trailing-whitespace)
  (mu4e-headers-mode . aleks/disable-show-trailing-whitespace)
  (mu4e-compose-mode . aleks/set-from-line)
  :custom
  (mu4e-mu-binary
   (concat
    (aleks/sequence-to-directory (getenv "HOME") ".emacs.d" "straight" "repos" "mu" "build" "mu")
    "mu"))
  (shr-color-visible-luminance-min 80)
  (mail-user-agent 'mu4e-user-agent)
  (mu4e-update-interval 60)
  (message-send-mail-function 'smtpmail-send-it)
  (mu4e-use-fancy-chars t)
  (mu4e-attachment-dir "~/Downloads")
  (mu4e-view-show-images t)
  (mu4e-headers-fields '((:human-date . 25)
                         (:flags . 6)
                         (:from . 22)
                         (:thread-subject . nil))))
#+END_SRC

** Multiple Cursors

#+begin_src emacs-lisp
  (use-package multiple-cursors)
#+end_src

** Pair Programmer Mode

A mode that eases working with people on code together. It turns on line numbers and also adds a =Co-Authored-By= stanza to every git commit while it is active.

#+begin_src emacs-lisp
  (defvar pair-programming-mode--pair-programmer nil
    "The current pair programmer as (name email)")

  (defun enable-pair-programming-mode ()
    "Set visuals for pair programming mode and prompt for your buddy."
    (global-display-line-numbers-mode 1)
    (let ((pair-programmer (git-commit-read-ident nil)))
      (setq pair-programming-mode--pair-programmer pair-programmer)
      (message (concat "Pair programming with " (car pair-programmer)))))

  (defun disable-pair-programming-mode ()
    "Disable pair programming visuals and settings."
    (setq pair-programming-mode--pair-programmer nil)
    (global-display-line-numbers-mode -1)
    (message "PP mode disabled"))

  (define-minor-mode pair-programming-mode
    "Toggle Pair Programming Mode.
  This prompts for a pair programmer from your current git commit history.
  When you commit with (ma)git, the pair programmer is inserted as a co-author.
  Additionally, line number mode is enabled."
    :group 'pair-programming
    :global t
    :lighter " PP"
    (if pair-programming-mode
        (enable-pair-programming-mode)
      (disable-pair-programming-mode)))

  (defun insert-pair-programmer-as-coauthor ()
    "Insert your pair programer into the current git commit."
    (when (and pair-programming-mode git-commit-mode)
      (pcase pair-programming-mode--pair-programmer
        (`(,name ,email) (git-commit-insert-header "Co-authored-by" name email))
        (_ (error "No pair programmer found or malformed content.")))))

  (add-hook 'git-commit-setup-hook 'insert-pair-programmer-as-coauthor)
#+end_src

** Parentheses

Highlight parentheses in different colours according to their nesting level.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Smartparens to make handling parentheses easier.

#+begin_src emacs-lisp
(use-package smartparens
  :demand t
  :init
  (require 'smartparens-config)
  :bind (:map smartparens-mode-map
              ("C-=" . 'sp-forward-slurp-sexp)
              ("C-/" . 'sp-forward-barf-sexp))
  :config
  (smartparens-global-mode 1)
  (show-smartparens-global-mode 1)
  :custom
  (sp-wrap-repeat-last 2) ;; repeat wrap with different pair
  (smartparens-strict-mode 1)
  (sp-show-pair-delay 0))
#+end_src

** Projectile
I haven't configured =projectile= to use =selectrum=, but it's working alright for now.

#+BEGIN_SRC emacs-lisp
(use-package projectile
  :bind (("C-c p p" . projectile-switch-project)
         ("C-c p b" . projectile-switch-to-buffer)
         ("C-c p f" . projectile-find-file)
         ("C-c p g" . consult-ripgrep))
 :config
  (projectile-mode +1))
#+END_SRC

** Pulsar
Protesilaos' take on beacon-mode is somewhat more lightweight and seems to be less error-prone.

#+begin_src emacs-lisp
  (use-package pulsar
    :custom
    (pulsar-pulse t)
    (pulsar-delay 0.025)
    (pulsar-iterations 10)
    (pulsar-face 'pulsar-generic)
    (pulsar-highlight-face 'pulsar-yellow)
    :config
    (pulsar-global-mode 1))
#+end_src

** Ripgrep

Near-instant full-text-search across projects.

#+BEGIN_SRC emacs-lisp
  (use-package rg)
#+END_SRC

** Selection

=helm= â†’ =ivy= â†’ =selectrum= â†’ =vertico=. You'd think something as simple as selecting which command to issue would be easy. Well, seems like the design space is unlimited.


Try out =selectrum= as an alternative to =ivy=.

#+begin_src emacs-lisp
(use-package vertico
  :straight (vertico :type git :host github :repo "emacs-straight/vertico")
  :init
  (vertico-mode)
  :custom
  (vertico-cycle t))

(use-package vertico-directory
  :straight (vertico-directory :type git :host github :repo "emacs-straight/vertico" :files ("extensions/*.el"))
  :after vertico
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

(use-package savehist
  :init
  (savehist-mode))
#+end_src

I've taken this verbatim from Vertico's readme. To be honest, I don't quite understand what these do.

#+begin_src emacs-lisp
  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
    (setq enable-recursive-minibuffers t))
#+end_src

Quicker matching with =orderless=

#+begin_src emacs-lisp
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless partial-completion basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

Use =prescient= for sorting options by /frecency/:

#+begin_src emacs-lisp
  (use-package prescient
    :config
    (prescient-persist-mode +1))

  (use-package vertico-prescient
    :after vertico
    :init (vertico-prescient-mode +1))
#+end_src

Add documentation to each selection entry if possible.

#+begin_src emacs-lisp
  (use-package marginalia
    :bind (:map minibuffer-local-map ("M-a" . marginalia-cycle))
    :init
    (marginalia-mode))
#+end_src

** Smerge

Awesome shortcuts to do complicated 3-way-merges with =git=.

** Snippets

Snippets live in version control under the Emacs directory.

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1)
    :custom
    (yas-snippet-dirs '("~/config/emacs/snippets")))
#+end_src

** Spacious Padding
Prot's sense for aesthetics is awesome. Unfortunately, the package doesn't play well with transparency.

#+begin_src emacs-lisp
(use-package spacious-padding
  :custom
  (spacious-padding-subtle-mode-line
   `( :mode-line-active 'default
      :mode-line-inactive vertical-border))
  (spacious-padding-widths
   '( :internal-border-width 15
      :header-line-width 4
      :mode-line-width 5
      :tab-width 4
      :right-divider-width 30
      :scroll-bar-width 8
      :fringe-width 8))
  :init
  (spacious-padding-mode))
#+end_src
** String Inflection

Useful to cycle between =CamelCase=, =snake_case=, etc. No keybindings, I just call it with =M-x=.

#+begin_src emacs-lisp
  (use-package string-inflection)
#+end_src

** Treemacs

A bit too visual for my taste, but sometimes comes in handy. Let's see if it's worth keeping it around

#+begin_src emacs-lisp
  (use-package treemacs
    :defer t)
#+end_src

And sync between projectile and treemacs

#+begin_src emacs-lisp
  (use-package treemacs-projectile
    :after (treemacs projectile))
#+end_src

And let treemacs know about staging files in git

#+begin_src emacs-lisp
  (use-package treemacs-magit
    :after (treemacs magit))
#+end_src

** Treesitter

Treesitter is now built-into Emacs 29.

First, compile tree-sitter and update your LD cache:

#+begin_src shell
  git clone https://github.com/tree-sitter/tree-sitter
  cd tree-sitter
  make all
  sudo make install
  sudo ldconfig
#+end_src

Then download some grammars. There's a little helper script:

#+begin_src shell
  git clone https://github.com/casouri/tree-sitter-module
  cd tree-sitter-module
  ./batch.sh
#+end_src

Then compile Emacs with ~--with-tree-sitter~. Finally, point ~treesit-extra-load-path~ to the above =tree-sitter-module= project.

#+begin_src emacs-lisp
  (require 'treesit)
  (setq treesit-extra-load-path
        (list "~/var/src/tree-sitter-module/dist"))
#+end_src

** Which-Key

=which-key= shows hints after pressing a prefix key. Greatly aids discoverability.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+END_SRC

** Whitespace

Switch on highlighting of trailing white space, and provide a facility to turn it off on a per-mode base, as for some modes it's not useful.

#+begin_src emacs-lisp
(custom-set-variables '(show-trailing-whitespace t))

(defun aleks/disable-show-trailing-whitespace ()
    "Disable trailing whitespace."
    (setq show-trailing-whitespace nil))

(add-hook 'calendar-mode-hook 'aleks/disable-show-trailing-whitespace)
(add-hook 'embark-collect-mode-hook 'aleks/disable-show-trailing-whitespace)
#+end_src

** Winner
Winner mode records window manipulation and allows you to undo/redo operations on windows. It is built-in, we just need to activate it.
#+begin_src emacs-lisp
(winner-mode)
#+end_src
** XJira

An integration for Jira I wrote. The only thing it does is offer a way to capture Jira issues in org-capture templates.

#+begin_src emacs-lisp
(use-package xjira
  :straight (xjira :type git :host github :repo "adimit/xjira"))
#+end_src

The authorisation and host variables are set in auth source.
