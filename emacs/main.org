* Info
This configuration assumes Emacs has been compiled like this:

#+begin_src shell
  make bootstrap && ./autogen.sh && CC=/usr/bin/gcc-10 CXX=/usr/bin/gcc-10 ./configure  --prefix=$HOME/.local/ --with-xwidgets --with-cairo --with-modules --without-compress-install --with-x-toolkit=yes --with-gnutls --without-gconf --without-toolkit-scroll-bars --without-xaw3d --without-gsettings --with-mailutils --with-native-compilation --with-json --with-harfbuzz --with-imagemagick --with-jpeg --with-png --with-rsvg --with-tiff --with-wide-int --without-xft --with-xml2 --with-tree-sitter --with-xpm CFLAGS="-O3 -mtune=native -march=native -fomit-frame-pointer" && make -j8 &&
make install
#+end_src

My current Emacs version is:

GNU Emacs 30.0.50 (build 3, x86_64-pc-linux-gnu, GTK+ Version 3.24.33, cairo version 1.16.0) of 2023-02-08

* Early Initialisation

Everything that is in here needs to happen early.

** Performance
There's a nice [[https://news.ycombinator.com/item?id=39124314][thread on HN]] about optimising Emacs. These are lifted from there.

#+begin_src emacs-lisp
(setq-default bidi-display-reordering 'left-to-right
              bidi-paragraph-direction 'left-to-right
              bidi-inhibit-bpa t)
(setq fast-but-imprecise-scrolling t
      redisplay-skip-fontification-on-input t
      inhibit-compacting-font-caches t)

(setq idle-update-delay 1.0)
#+end_src

Don't do garbage collection in the minibuffer

#+begin_src emacs-lisp
(defun my-minibuffer-setup-hook ()
  (setq gc-cons-threshold most-positive-fixnum))

(defun my-minibuffer-exit-hook ()
  (setq gc-cons-threshold (* 32 1024 1024)))

(add-hook 'minibuffer-setup-hook #'my-minibuffer-setup-hook)
(add-hook 'minibuffer-exit-hook #'my-minibuffer-exit-hook)
#+end_src

This shows me GC breaks, to help debug performance problems.

#+begin_src emacs-lisp
(defmacro aleks/trace (msg sym &optional threshold)
  "Trace SYM with MSG, optionally only if duration is over THRESHOLD.

If threshold is non-nil, suppresses the start message to keep things
from getting too noisy."
  `(advice-add
    ,sym :around
    (lambda (orig &rest args)
      (progn
        (unless ,threshold (message "tracing %s" ,msg))
        (let* ((start-time (current-time))
               (result (apply orig args))
               (end-time (float-time (time-subtract (current-time) start-time))))
          (if (or (not ,threshold)
                  (< ,threshold end-time))
              (message "tracing %s took %fs." ,msg end-time))
          result)))))

(aleks/trace "garbage collection" 'garbage-collect 0.2)
#+end_src

** Straight
The initialization code for =straight.el= that lives [[https://github.com/raxod502/straight.el#getting-started][in the straight.el readme]] is already loaded in =init.el=.

Note that you also have to place the following in your =early-init.el=:

#+begin_src emacs-lisp :tangle no
  (setq package-enable-at-startup nil)
#+end_src

** Use-Package

For general package management use use-package, and instruct it to always use straight.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (custom-set-variables
   '(straight-use-package-by-default t))
#+end_src

** Environment

Slurp the shell environment into Emacs when started as a daemon.

#+begin_src emacs-lisp
(use-package exec-path-from-shell
  :custom exec-path-from-shell-variables
  '("PATH" "MANPATH"))
(use-package general)
(when (daemonp)
  (exec-path-from-shell-initialize))
#+end_src

* Emacs

Tweak various aspects of Emacs' visuals and behaviour.

** Appearance & Behaviour

Some basic appearance & behaviour settings

#+begin_src emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
  (set-face-attribute hl-line-face nil :underline nil)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (custom-set-variables
   '(inhibit-startup-screen t)
   ; prevent emacs from trying to resize the frame
   '(frame-inhibit-implied-resize t)
   '(indent-tabs-mode nil)
   '(initial-scratch-message "")
   '(mouse-yank-at-point t))
#+end_src

** Auth
This uses =pass= for all auth storage, including =mu4e= and =ghub=. If there are problems remember =(setq auth-source-debug t).=

#+begin_src emacs-lisp
  (auth-source-pass-enable)
#+end_src

Let Emacs query the pass phrase instead of an external pinentry dialogue.

#+begin_src emacs-lisp
  (customize-set-variable 'epg-pinentry-mode 'loopback)
#+end_src

** Backups

No files with =~= everywhere. Prevent creation of lockfiles, as that confuses some watch tasks (notably webpack dev server.)

#+BEGIN_SRC emacs-lisp
(custom-set-variables
 '(backup-directory-alist `(("." . "~/.saves")))
 '(delete-old-versions t)
 '(kept-new-versions 6)
 '(kept-old-versions 2)
 '(version-control t)
 '(backup-by-copying t)
 '(make-backup-files t)
 '(create-lockfiles nil))
#+END_SRC

** Calendar
Calendar is set up for European style display (Monday starts week) and manual location of TÃ¼bingen, Germany (for sunrise/sunset).
TÃ¼bingen Hbf is: =48.516738, 9.055493=

#+BEGIN_SRC emacs-lisp
  (defvar holiday-baden-wÃ¼rttemberg-holidays
    '((holiday-fixed 1 1 "Neujahr")
      (holiday-fixed 1 6 "Heilige Drei KÃ¶nige")
      (holiday-fixed 5 1 "Tag der Arbeit")
      (holiday-fixed 10 3 "Tag der deutschen Einheit")
      (holiday-fixed 11 1 "Allerheiligen")
      (holiday-fixed 12 25 "Erster Weihnachtsfeiertag")
      (holiday-fixed 12 26 "Zweiter Weihnachtsfeiertag")
      (holiday-easter-etc -2 "Karfreitag")
      (holiday-easter-etc +1 "Ostermontag")
      (holiday-easter-etc +39 "Christi Himmelfahrt")
      (holiday-easter-etc +50 "Pfingstmontag")
      (holiday-easter-etc +60 "Fronleichnam")))

  (use-package calendar
    :defer t
    :custom
    (calendar-week-start-day 1)
    (calendar-latitude 48.516738)
    (calendar-longitude 9.055493)
    (calendar-location-name "TÃ¼bingen, Germany")
    (calendar-holidays
     (append holiday-solar-holidays
             holiday-baden-wÃ¼rttemberg-holidays))
    (calendar-date-style 'european)
    (calendar-time-display-form
     '(24-hours ":"
                minutes
                (if time-zone (concat " (" time-zone ")")))))
  
#+END_SRC

Here's a function that returns whether it's currently dark outside, so you don't have to look.

#+begin_src emacs-lisp
  (defun aleks/is-it-dark-p ()
    "Return t if it's dark outside, otherwise nil.

  Will look at the `current-time' and calculate sunset and sunrise times
  according to `calendar-longitude' and `calendar-latitude' using
  `solar-sunrise-sunset'so make sure you've set your location."
    (require 'solar)
    (let* ((solar (solar-sunrise-sunset (calendar-current-date)))
	 (sunrise (car (car solar)))
	 (sunset (car (car (cdr solar))))
	 (time (decode-time (current-time)))
	 (hour (nth 2 time))
	 (minute (nth 1 time))
	 (minute-fraction (/ minute 60.0))
	 (time-decimal (+ hour minute-fraction)))
    (or (> time-decimal sunset) (< time-decimal sunrise))))
#+end_src

** Emacs-Server

Enable emacs server mode.

#+begin_src emacs-lisp
  (server-mode)
#+end_src

There are two shell aliases that help with server mode:

#+begin_src shell
  alias ec=emacsclient -n
  alias ecc=emacsclient -cn
#+end_src

=ecc= opens another frame, and =ec= just re-uses an existing frame.
** Eshell

A function to open a new shell in the current buffer's file's directory. It's lifted [[https://www.reddit.com/r/emacs/comments/1zkj2d/advanced_usage_of_eshell/][from here]].

#+begin_src emacs-lisp
  (defun eshell-here ()
    "Opens up a new shell in the directory associated with the current buffer's file."
    (interactive)
    (let* ((parent (file-name-directory (buffer-file-name)))
           (name   (car
                    (last
                     (split-string parent "/" t)))))
      (split-window-vertically)
      (other-window 1)
      (eshell "new")
      (rename-buffer (concat "*eshell: " name "*"))
      (insert (concat "ls"))
      (eshell-send-input)))
#+end_src

** Font

Instead of using a package like =org-variable-pitch-mode=, the
following definition takes care of setting up which parts of
=org-mode= are fixed pitch.

#+begin_src emacs-lisp
(defun aleks/set-org-mode-fixed-pitch-faces ()
  (mapc (lambda (face) (set-face-attribute face nil :family (face-attribute 'fixed-pitch :family)))
        `(org-block
          org-special-keyword
          org-drawer
          org-todo
          org-code
          org-priority
          org-checkbox
          org-block-end-line
          org-block-begin-line
          org-table
          org-verbatim)))
#+end_src

And here's a function to set the different faces.

#+begin_src emacs-lisp
(defun aleks/set-light-mode-faces ()
    "Set the faces for light mode."
    (custom-set-faces
     '(variable-pitch ((t (:family "Bitter" :height 180))))
     '(fixed-pitch ((t (:family "Fira Code" :height 160))))
     '(default ((t (:family "Fira Code" :height 160)))))
    (set-fontset-font "fontset-default" 'greek-iso8859-7 '("Fira Code Regular")))
#+end_src

We're setting the fontset font for the Greek code page explicitly, because Emacs had trouble finding it and would use some ugly serif font instead. Ideally, this shouldn't be necessary. I think this is a bug, but I've not yet tried reproducing it in a minimal session.

These are triggered after [[Theme]] selection.

** Mime Types

Handle specific file types. This is used especially by =ein-python=.

#+begin_src emacs-lisp
  (custom-set-variables
   '(mailcap-user-mime-data
     '((viewer . "eog %s")
       (type . "image/.*"))))
#+end_src

** Mode Line

Doom's mode line. Not the prettiest thing in the world, but it just works. There's also [[https://github.com/rougier/nano-modeline][nano-modeline]] which I like more, but it doesn't work with LSP ootb, and I can't be bothered to make it work with LSP.

#+begin_src emacs-lisp
  (use-package doom-modeline
    :init (doom-modeline-mode 1)
    :custom
    (doom-modeline-icon t)
    (doom-modeline-major-mode-icon t)
    (doom-modeline-buffer-state-icon t)
    (doom-modeline-buffer-encoding nil)
    (doom-modeline-modal-icon t)
    (doom-modeline-lsp t))

  (use-package nerd-icons
    :if (display-graphic-p))
#+end_src

** Scrolling

This mimics helix editor: scroll one line at a time, leaving some margin at the edges:

#+begin_src emacs-lisp
  (custom-set-variables
   '(mouse-wheel-scroll-amount '(1 ((shift) . 1)))
   '(mouse-wheel-progressive-speed nil)
   '(mouse-wheel-follow-mouse 't)
   '(scroll-step 1)
   '(scroll-margin 6)
   '(scroll-conservatively 101))
#+end_src

The weird thing here is =scroll-conservatively=. It controls how Emacs scrolls once the point moves out of view. The default (0) means that it will always recenter the screen on the point. A value greater than 100 means that it will never do that, and always just try to scoot the buffer so the cursor is visible on the edge.

Since Emacs 29, we've got smooth scrolling, too.

#+begin_src emacs-lisp
  (if (>= emacs-major-version 29)
      (custom-set-variables
       '(pixel-scroll-precision-mode t)
       '(pixel-scroll-precision-large-scroll-height 40.0)
       '(pixel-scroll-precision-interpolation-factor 8.0)))
#+end_src

The interpolation factor dictates scroll speed.

** Search
#+begin_src emacs-lisp
(custom-set-variables
 '(isearch-lazy-count t)
 '(isearch-yank-on-move t))
#+end_src

** Text buffers

When reading and writing text, the buffer shouldn't get too wide. Olivetti mode takes care of that.

Moreover, =text-mode= buffers should have spell check enabled, be narrowed, and use variable pitch and word wrap. However, a variety of buffers seem to trigger =text-mode-hook= that, in my opinion, have no business doing so. So we also define an exclusion list.

#+begin_src emacs-lisp
  (defconst not-really-text-modes
    '(yaml-mode nxml-mode mhtml-mode)
    "Modes that somehow trigger the `text-mode-hook' but aren't really text.")

  (defun aleks/text-mode-hook ()
    "Set up the current `major-mode' for writing text unless it's a member of `not-really-text-modes'."
    (unless (member major-mode not-really-text-modes)
      (message (format "Setting up %s for writing prose." major-mode))
      (flyspell-mode)
      (visual-line-mode)
      (variable-pitch-mode)
      (olivetti-mode)))

  (use-package olivetti
    :hook (text-mode . aleks/text-mode-hook))
#+end_src

** Theme

Use Prot's awesome Modus theme, vivendi by default. They're built-in.

#+begin_src emacs-lisp
(load-theme 'modus-vivendi 'no-confirm)
(setq modus-themes-italic-constructs t
          modus-themes-bold-constructs t
          modus-themes-region '(bg-only no-extend)
          modus-themes-scale-headings t
          modus-themes-slanted-constructs t
          modus-themes-scale-1 1.1
          modus-themes-scale-2 1.2
          modus-themes-scale-3 1.3
          modus-themes-scale-4 1.4
          modus-themes-scale-5 1.5)
(add-hook 'org-mode-hook 'aleks/set-org-mode-fixed-pitch-faces)
(add-hook 'prog-mode-hook 'aleks/set-light-mode-faces)
#+end_src

** Undo
We want more generous undo limits, because I make mistakes quite often and I use modern computers.

#+begin_src emacs-lisp
(custom-set-variables
 '(undo-limit (expt 2 24)) ; 16MiB
 '(undo-strong-limit (expt 2 26)) ; 64MiB
 '(undo-outer-limit (expt 2 28))) ; 256MiB
#+end_src

** Utility functions

*** Append to =org-babel-load-languages=

I'd like to append to =org-babel-load-languages= right from a =use-package= =:config= declaration, to keep configuration neat. The following macro loads the Org Babel definition and appends it to =org-babel-load-languages=, instead of overwriting the content of the variable. Accepts a list in the form ='((R . t))=.

#+begin_src emacs-lisp
  (defmacro aleks/org-babel-load-languages (list)
    "Load the language definitions in LIST and add them to `org-babel-load-languages'."
    `(org-babel-do-load-languages
      'org-babel-load-languages
      (append org-babel-load-languages ,list)))
#+end_src

* Major Modes

A list of supported major modes and their configuration.

** CSS
#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css$"
    :custom (css-indent-offset 2))
  (use-package scss-mode
    :mode ("\\.scss$" "\\.sass$"))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :mode "\\.[ct]sv$")
#+END_SRC

** Cucumber
This is useful for ecukes tests. I don't use those myself, but some other packages are covered by ecukes.

#+begin_src emacs-lisp
(use-package feature-mode
  :mode "\\.feature\\'")
#+end_src
** Docker

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode :mode "Dockerfile")
#+END_SRC

** Emacs Lisp
ELisp mode is, of course, built in, but there are some ways to enhance it.

Eros mode shows you the result of elisp expressions in-band, instead of in the mini-buffer. It also has an embark style functionality where you can just inspect the last result which we bind to a useful key.

#+begin_src emacs-lisp
(use-package eros
  :bind (("C-c s i" . eros-inspect-last-result))
  :config
  (eros-mode 1))
#+end_src
** Fish

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode "\\.fish$")
#+END_SRC

** Graphql

#+BEGIN_SRC emacs-lisp
  (use-package request)

  (use-package graphql-mode
    :load-path "~/src/graphql-mode/"
    :mode "\\.graphql$"
    :custom (graphql-indent-level 2))
#+END_SRC

** Graphviz

Add =graphviz-dot-mode= to facilitate writing of graphviz graphs

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
#+end_src

Also add =ob-dot= to embed graphs in Org mode

#+begin_src emacs-lisp
  (aleks/org-babel-load-languages '((dot . t)))
#+end_src

** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :mode "build\\.gradle" "\\.groovy$")
#+END_SRC

** Haskell

Haskell support via =haskell-mode= and LSP.

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.l?hs\\'")

  (use-package lsp-haskell
    :hook
    (haskell-mode . lsp)
    (haskell-literate-mode . lsp))
#+END_SRC

** Json
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json$"
    :config
    (add-to-list 'flycheck-disabled-checkers 'json-python-json))
#+END_SRC

** Kotlin

There's some support via Kotlin's LSP server. It isn't nearly good enough yet, but it gets you most of the way there.

We enable =display-fill-column-indicator-mode= because =ktlint= errors out when the line is too long.

The Kotlin language server likes to eat gigabytes of RAM, so I only activate it manually.

#+BEGIN_SRC emacs-lisp
(use-package kotlin-mode
  :mode "\\.kt$"
  :hook
  ;; (kotlin-mode . lsp)
  (kotlin-mode . display-fill-column-indicator-mode))
#+END_SRC

** Ledger

The function =browse-amazon-history-at-point= is useful to get to the Amazon order number from the bank statement itself. Helps with categorisation.

#+BEGIN_SRC emacs-lisp
  (defun browse-amazon-history-at-point ()
    "Open amazon.de order history.  The search term is `thing-at-point'."
    (interactive)
    (browse-url (concat "https://www.amazon.de/gp/your-account/order-history/?search=" (thing-at-point 'symbol 'no-props))))

  (use-package ledger-mode
    :mode "hledger\\.journal$" "\\.ledger$")

  (use-package flycheck-ledger
    :after flycheck ledger-mode)
#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode "\\.lua$"
    :interpreter "lua")
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md$"
    :custom (markdown-fontify-code-blocks-natively t))
#+END_SRC

** Org
Loading org already happened in =init.el=.

*** Keybindings
#+begin_src emacs-lisp
(use-package org
  :bind (("C-c o a" . org-agenda)
         ("C-c o C" . org-capture)
         ("C-c o c c" . org-capture)
         ("C-c o n" . org-toggle-narrow-to-subtree)
         ("C-c o l" . org-demote-subtree)
         ("C-c o h" . org-promote-subtree)
         ("C-c o c o" . org-clock-out)
         ("C-c o c i" . org-clock-in)
         ("C-c o c g" . org-clock-goto)))
#+end_src

*** Agenda

The most important files get their own variables.

#+begin_src emacs-lisp
  (defcustom org-directory (concat (file-name-as-directory (getenv "HOME")) "org") "Org directory.")
  (defcustom my-org-main-file (concat (file-name-as-directory org-directory) "main.org") "Personal Org agenda file.")
  (defcustom my-org-work-file (concat (file-name-as-directory org-directory) "work.org") "Professional Org agenda file.")
#+end_src

Add diary and agenda files.

#+begin_src emacs-lisp
  (custom-set-variables
   '(org-agenda-include-diary t)
   '(org-agenda-files `(,my-org-main-file ,my-org-work-file))
   '(diary-file (concat (file-name-as-directory org-directory) "diary")))
#+end_src

And here's a plugin to put everything into nice sections, and get a better overview of the agenda

#+begin_src emacs-lisp
  (use-package org-super-agenda
    :hook
    (org-agenda-mode . org-super-agenda-mode)
    :config
    (setq ; this essentially resets `org-super-agenda-header-map' to an empty (pass-through) keymap
     org-super-agenda-header-map (make-sparse-keymap)
     org-super-agenda-groups
     '((:name "Work"
              :file-path "work.org")
       (:name "Meetings"
              :file-path "work.org"
              :todo "MEET")
       (:name "Personal"
              :todo "TODO"
              :tag "family"
              :file-path "main.org"))))
#+end_src

*** Babel

Tangle every block by default.

#+begin_src emacs-lisp
  (add-to-list 'org-babel-default-header-args '(:tangle . "yes"))
#+end_src

Redisplay images after code block evaluation. Handy if the result of your computation is an image: it'll pop up immediately.

#+begin_src emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src

*** Capture

Capture templates:

#+begin_src emacs-lisp
(defun join-lines (strings)
  "Join STRINGS with newlines."
  (string-join strings "\n"))

(customize-set-variable
 'org-capture-templates
 `(("c" "Add to today" entry
    (file+regexp my-org-main-file "Week [0-9][0-9]?")
    ,(join-lines
      '("* TODO %?"
        "SCHEDULED: %t"
        ":PROPERTIES:"
        ":CREATED: %U"
        ":END:"
        "")))
   ("W" "Plan Week" entry (file my-org-main-file)
    ,(join-lines
      '("* Week %(aleks/get-next-week-number)"
        "** TODO Prepare Cat Meds"
        "** TODO Clean Bathroom"
        "** TODO Weekly Review"
        "** TODO Vacuum & Mop"
        "** TODO Make Yogurt"
        "** TODO Feed Sourdough")))
   ("s" "Add task to sprint" entry
    (file+headline my-org-work-file "Tasks")
    ,(join-lines
      '("* TODO %?"
        "SCHEDULED: %t"
        ":PROPERTIES:"
        ":CREATED: %U"
        ":REFERENCE: %f"
        ":END:"
        ""
        "%i")))
   ("j" "Add MP Jira ticket" entry
    (file+headline my-org-work-file "Tasks")
    ,(join-lines
      '("* TODO %(xjira-org-capture-issue \"KNUTH\") %(xjira-get 'issue) %(xjira-get 'title)"
        "SCHEDULED: %t"
        ":PROPERTIES:"
        ":REFERENCE: %(eval (xjira-make-org-link (xjira-get 'issue) (xjira-get 'title)))"
        ":Parent: %(eval (xjira-make-org-link (xjira-get 'parent) (xjira-get 'parent-title)))"
        ":Epic: %(eval (xjira-make-org-link (xjira-get 'epic) (xjira-get 'epic-title)))"
        ":Reporter: %(xjira-get 'reporter)"
        ":END:"
        ""
        "#+begin_quote"
        "%(xjira-get 'description)"
        "#+end_quote")))
   ("M" "Morning routine tasks" entry
    (file+headline my-org-work-file "Tasks")
    ,(join-lines
      '("* TODO Morning Routine on %(calendar-date-string (calendar-current-date))"
        "SCHEDULED: %t"
        ""
        "- [ ] [[https://sentry.io/organizations/meisterplan/issues/][Sentry]]"
        "- [ ] [[https://meisterplan.zendesk.com/agent/dashboard][Support Tickets]]"
        "- [ ] Tests & CVEs")))
   ("m" "Add meeting" entry
    (file+headline my-org-work-file "Meetings")
    ,(join-lines
      '("* MEET %?"
        "SCHEDULED: %^T"
        ":PROPERTIES:"
        ":REFERENCE:"
        ":END:")))
   ("S" "Sprint" entry (file my-org-work-file)
    ,(join-lines
      '("* Sprint %^{Title}"
        "** Meetings"
        "*** MEET EG Backend"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 7) '(10 30))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval eg-backend-confluence-link)"
        ":END:"
        "*** MEET Refinement 1"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 8) '(9 30))"
        "*** MEET Refinement 2"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 10) '(9 30))"
        "*** MEET EG Frontend"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 14) '(10 00))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval eg-frontend-confluence-link)"
        ":END:"
        "*** MEET Refinement 3"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 15) '(9 30))"
        "*** MEET Sprint Review"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-review-day) '(15 30))"
        "*** MEET Retro"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(9 00))"
        "*** MEET Next sprint SP1"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(10 00))"
        "*** MEET Next sprint SP2"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(13 00))"
        "** Tasks"
        "*** TODO Prepare Sprint Start Sheet"
        ":PROPERTIES:"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 3) '(16 00))"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "*** TODO Update Metrics"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/monday-this-week (aleks/next-sprint-review-day)))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "*** TODO Check that metrics are defined"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 16) '(9 00))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "*** TODO Calculate Velocity & Actuals"
        "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/gregorian-relative-to 16) '(16 30))"
        ":PROPERTIES:"
        ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
        ":END:"
        "%i%?")))))
#+end_src

*** Citations

Only works with the new (as of summer 2021) org citation support.

#+begin_src emacs-lisp
  (defvar aleks/global-bibliography-files '("~/doc/lib/bib/main.bib"))
  (custom-set-variables
   '(org-cite-global-bibliography aleks/global-bibliography-files))
#+end_src

We install =citeproc= to get the CSL backend.

#+begin_src emacs-lisp
  (use-package citeproc
    :config
    (require 'oc-csl))
#+end_src

We set the export backend to biblatex for latex.

#+begin_src emacs-lisp
  (custom-set-variables
   '(org-cite-export-processors
     '((latex biblatex)
       (t csl))))
#+end_src

*** Contrib

=org-contrib= is its own repo now, so we need to make it available.

#+begin_src emacs-lisp
  (use-package org-contrib
    :config
    (require 'ox-confluence))
#+end_src

*** Customisation

And we set a lot of configuration options for org.

#+begin_src emacs-lisp
(custom-set-variables
 '(org-tags-column 0) ; alignment broken with variable pitch
 '(org-confirm-babel-evaluate nil) ; don't prompt when evaluating
 '(org-startup-folded t)
 '(org-hide-emphasis-markers t)
 '(org-babel-confirm-evaluate nil)
 '(org-log-into-drawer t)
 '(org-catch-invisible-edits 'show-and-error)
 '(org-special-ctrl-a/e t)
 '(org-log-into-drawer t)
 '(org-ellipsis "â€¦")
 '(org-fontify-whole-heading-line t)
 '(org-pretty-entities t)
 '(org-agenda-tags-column 0)
 '(org-edit-src-content-indentation 0)
 '(org-image-actual-width nil) ; Take the width from ORG_ATTRs
 '(org-outline-path-complete-in-steps nil) ; use a flat list instead of hierarchichal steps
 '(org-refile-targets
   '((nil . (:maxlevel . 4)))) ; don't descend more than 4 levels when refiling
 '(org-footnote-section nil)) ; place footnotes in same section
#+end_src

*** Export

Enable export back ends not enabled by default.

#+begin_src emacs-lisp
  (require 'org)
  (customize-set-variable
   'org-export-backends (append org-export-backends '(md)))
#+end_src

*** Inline Latex

Render inline LaTeX fragments somewhat bigger, to match the font size.
#+begin_src emacs-lisp
  (plist-put org-format-latex-options :scale 2)
#+end_src

*** Hugo
Write blog posts & website with a static site generator, Hugo.

#+begin_src emacs-lisp
(use-package ox-hugo
  :after ox)
#+end_src

*** Reveal

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :custom
    (org-reveal-root "file:///home/aleks/src/talks/reveal.js-4.1.0")
    (org-reveal-hlevel 2))
  (use-package htmlize)
#+END_SRC

*** Visuals

I don't like the bold red colour for TODO items. I dread them enough without them screaming into my face.

#+begin_src emacs-lisp
(set-face-attribute 'org-todo nil :foreground (alist-get 'blue modus-themes-vivendi-colors))
#+end_src

Prettier lists, by substituting bullet points for list item markers.

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 () (compose-region
                    (match-beginning 1)
                    (match-end 1)
                    "â€¢"))))))
#+END_SRC

Org-appear allows easy editing of inline markup when it's hidden.

#+begin_src emacs-lisp
  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autolinks t)
    (org-appear-autosubmarkers t)
    (org-appear-autoemphasis t)
    :straight (org-appear :type git
                :host github
                :repo "awth13/org-appear"))
#+end_src

There's a way to dynamically generate SVGs and inline them in =org= to improve the visuals, but it needs pretty complex configuration that I haven't done yet.

*** Org -Journal

An alternative might be to use =org-roam-dailies= but I saw no benefits so far.

#+begin_src emacs-lisp
(use-package org-journal)
#+end_src
*** Org Modern
A modern look for org mode.

#+begin_src emacs-lisp
(use-package org-modern
  :custom
  (org-modern-star '("ðŸž´" "ðŸž³" "ðŸž²" "ðŸž±" "ðŸž°"))
  :config
  (global-org-modern-mode)
  (set-face-attribute 'org-modern-done nil :family (face-attribute 'fixed-pitch :family))
  (set-face-background 'fringe (face-attribute 'default :background)))
#+end_src
*** Org Present
A thin presentation mode for org documents. I'll be using this for sprint reviews  and similar occasions.

#+begin_src emacs-lisp
(defun aleks/org-present-enter ()
  "Called by `org-present-mode-hook' to set up presentations."
  (org-present-big)
  (org-display-inline-images)
  (org-present-hide-cursor)
  (org-present-read-only)
  (setq header-line-format " ")
  (org-overview)
  (setq-local face-remapping-alist
              '((default (:height 1.5) variable-pitch)
                (header-line (:height 4.0) variable-pitch)
                (org-document-title (:height 1.75) org-document-title)
                (org-code (:height 1.25) org-code)
                (org-verbatim (:height 1.25) org-verbatim)
                (org-block (:height 1.25) org-block)
                (org-block-begin-line (:height 0.7) org-block))))


(defun aleks/org-present-leave ()
  "Called by `org-present-mode-quit-hook' to roll back all changes to the buffer."
  (org-present-small)
  (org-present-show-cursor)
  (org-present-read-write)
  (setq-local face-remapping-alist '((default variable-pitch default)))
  (setq header-line-format nil))

(use-package org-present
  :commands org-present
  :hook
  (org-present-mode . aleks/org-present-enter)
  (org-present-mode-quit . aleks/org-present-leave))
#+end_src

*** Org-Ref

I'm using org-cite nowadays, but org-ref still has important goodies.

#+begin_src emacs-lisp
(use-package org-ref
  :custom
  (reftex-default-bibliography '("~/doc/lib/bib/main.bib"))
  (org-ref-default-bibliography '("~/doc/lib/bib/main.bib"))
  (org-ref-pdf-directory '("~/doc/lib")))

#+end_src
*** Org-Roam


Mostly for lecture notes, ideas for talks, but also random thoughts.

#+begin_src emacs-lisp
  (use-package org-roam
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename (concat (file-name-as-directory (getenv "HOME")) "org/roam")))
    :config
    (org-roam-setup))
#+end_src

**** UI

Not very useful, except as a motivation to have the network grow.

#+begin_src emacs-lisp
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t
            org-roam-ui-open-on-start t))
#+end_src

*** Org-tufte
This is a small package that bundles [[https://edwardtufte.github.io/tufte-css/][Tufte's CSS]] with org mode to make something on the web that resembles [[https://tufte-latex.github.io/tufte-latex/][Tufte's handouts]]. It might come in useful for presentations or blogs, but I'd probably want to modify the CSS a bit.

#+begin_src emacs-lisp
(use-package org-tufte
  :straight
  (org-tufte :type git :host github :repo "Zilong-Li/org-tufte")
  :custom
  (org-tufte-htmlize-code t))
#+end_src

** PlantUML

=plantuml-mode= doesn't seem actively developed, but then again, PlantUML isn't exactly the latest and greatest either.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :mode "\\.plantuml\\'"
    :custom
    (plantuml-executable-path "/usr/bin/plantuml")
    (plantuml-default-exec-mode 'executable)
    (org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    :init
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
#+end_src

** Protobuf

For Google's =.proto= spec files

#+begin_src emacs-lisp
  (use-package protobuf-mode)

  (defconst aleks/protobuf-style
    '((c-basic-offset . 2)
      (indent-tabs-mode . nil)))

  (add-hook 'protobuf-mode-hook
    (lambda () (c-add-style "mp-protobuf-style" aleks/protobuf-style t)))
#+end_src

** Python

LSP support with MS's server:

#+begin_src emacs-lisp
  (use-package lsp-python-ms
    :custom (lsp-python-ms-auto-install-server t)
    :hook (python-mode . lsp))
#+end_src

Jupyter notebook support (mainly for org.)

#+begin_src emacs-lisp
  (use-package ein
    :custom
    (ein:output-area-inlined-images t)
    :config
    (aleks/org-babel-load-languages '((ein . t))))
#+end_src

Add =elpy=

#+begin_src emacs-lisp
  (use-package elpy
    :defer t
    :init
    (advice-add 'python-mode :before 'elpy-enable))
#+end_src

** R

#+begin_src emacs-lisp
  (use-package ess
    :config
    (aleks/org-babel-load-languages '((R . t))))
#+end_src

** Racket

Support for the Racket programming language. I used this for AoC.

#+begin_src emacs-lisp
  (use-package racket-mode
    :custom
    (racket-program "/usr/bin/racket")
    :hook
    (racket-mode . racket-xp-mode)
    :custom-face
    (racket-xp-unused-face ((t (:foreground "dark gray" :strike-through nil))))
    :init
    )
#+end_src

** REST

Rest client with org support.

#+begin_src emacs-lisp
  (use-package restclient
    :mode "\\.rest$")

  (use-package ob-restclient
    :after (restclient)
    :config
    (aleks/org-babel-load-languages '((restclient . t))))
#+end_src

** Rust

Rustic mode works well with =rust-analyzer=. Format on save is done with [[Apheleia]] via =rustfmt=.

#+begin_src emacs-lisp
(use-package rustic
  :hook
  (rustic-mode . lsp)
  (rustic-mode . copilot-mode)
  :custom
  (rustic-lsp-server 'rust-analyzer)
  (lsp-rust-server 'rust-analyzer)
  (lsp-rust-analyzer-server-command '("~/.local/bin/rust-analyzer")))
#+end_src

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook (rust-ts-mode . lsp))
#+end_src

** Typescript

Syntax highlighting via newly integrated tree-sitter (Emacs 29).

#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.tsx?\\'" . typescript-ts-mode))
#+end_src

When looking up React functional components, LSP returns React type signatures from React's own definitions in addition to the definition of the component itself. I'm not terribly interested in those, so we filter them out with a crude heuristic (a certain verbatim type signature and file location).

LSP lacks a general entrypoint to filter these out. See [[https://github.com/emacs-lsp/lsp-mode/issues/2103][this issue]].

#+begin_src emacs-lisp
(require 'cl-seq)
(require 'eieio)
(require 'xref)

(defun aleks/xref-react-type-definition-p (item)
  "Return t if `item' is a React type definition."
  (and
   (string-match-p "ReactElement<any, any>" (xref-item-summary item))
   (string-suffix-p "@types/react/index.d.ts" (xref-file-location-file (xref-item-location item)))))

(defun aleks/filter-react-type-definitions (items)
  "Remove React FunctionComponent type definitions from xref-items."
  (cl-remove-if #'aleks/xref-react-type-definition-p items))

(advice-add 'lsp--locations-to-xref-items :filter-return #'aleks/filter-react-type-definitions)
#+end_src

While we're at it, =xref= defaults to popping up a window whenever there's more than one definition it could jump to. That's annoying, I'd prefer it to just use ~completing-read~, which would use =corfu=. We can set ~xref-show-definitions-function~ to achieve that. (This will work in Emacs 28.1 or higher only.) This is most useful in TS because a symbol may at the same time be a value definition and a type name.

#+begin_src emacs-lisp
(setq xref-show-definitions-function #'xref-show-definitions-completing-read)
#+end_src

There's experimental support for inlay hints in typescript language server. I've disabled some inlay hints to improve performance. I'm using =corfu= and hence I've turned off ~lsp-completion-provider~ here

#+begin_src emacs-lisp
(use-package lsp-mode
  :defer t
  :mode
  ("\\.ts\\'" . typescript-ts-mode)
  ("\\.tsx\\'" . tsx-ts-mode)
  :init
  (defun aleks/lsp-mode-setup-completion ()
    (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
          '(orderless)))
  :hook
  (lsp-completion-mode . aleks/lsp-mode-setup-completion)
  (typescript-ts-mode . lsp)
  (tsx-ts-mode . lsp)
  (typescript-ts-mode . copilot-mode)
  (tsx-ts-mode . copilot-mode)
  :custom
  (lsp-completion-provider :none) ; Corfu
  (lsp-javascript-display-inlay-hints nil)
  (lsp-javascript-display-enum-member-value-hints nil)
  (lsp-javascript-display-parameter-type-hints nil)
  (lsp-javascript-display-parameter-name-hints nil)
  (lsp-javascript-display-return-type-hints nil)
  (lsp-javascript-display-property-declaration-type-hints nil)
  (lsp-javascript-display-variable-type-hints nil)
  :config
  (defun js-set-inlay-face ()
    (set-face-attribute
     'lsp-javascript-inlay-face nil
     :inherit 'variable-pitch
     :foreground "#787878"
     :height 1.0)))
#+end_src

** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode :mode "\\.ya?ml$")
#+END_SRC

* Utilities

Various add-ons outside of major mode functionality and Emacs core functionality.

** Apheleia (Auto-format on save)
Use [[https://github.com/raxod502/apheleia][Apheleia]] for on-save-actions, e.g. =prettier=, =black=, =rustfmt=.

=rustfmt= isn't supported out of the box. I've opened a [[https://github.com/raxod502/apheleia/pull/45][PR]]. In the meantime, we define our own.

#+begin_src emacs-lisp
(use-package apheleia
  :straight (apheleia :type git
                      :host github
                      :repo "raxod502/apheleia")
  :config
  (apheleia-global-mode +1))
#+end_src

** Avy

Jump to arbitrary points in the buffer

#+begin_src emacs-lisp
(use-package avy
  :config
  :general (:states 'normal
                    "g c" 'avy-goto-char
                    "g l" 'avy-goto-line)
  :custom (avy-all-windows 'all-frames))
#+end_src

** Buttercup
This is just for testing elisp files. Having it in the config allows me to execute the tests from within my active Emacs session, and not just using =eldev=.

#+begin_src emacs-lisp
(use-package buttercup)
#+end_src

** Calculate Sprints

A utility function to calculate the next sprint review's date (usually) from today.

Note that we have to wrap =calendar-day-of-week= even though I've already set =calendar-week-start-day= to =1=, because weekdays are always 0-indexed at Sunday.

#+begin_src emacs-lisp
(require 'calendar)
(require 'cal-dst)
(require 'cal-iso)

(defun aleks/calendar-day-of-week (arg)
  "Get the day of week for ARG, European style.

0 for Monday, â€¦ 6 for Sunday."
  (let ((anglo-day-of-week (calendar-day-of-week arg)))
    (if (= 0 anglo-day-of-week)
        6
      (- anglo-day-of-week 1))))

(defun aleks/get-next-week-number ()
  "Return next week's ISO week number, based on `calendar-current-date'."
  (let* ((monday (aleks/monday-this-week (calendar-current-date)))
         (monday-next-week (+ (calendar-absolute-from-gregorian monday) 7))
         (monday-midnight-next-week (calendar-time-from-absolute monday-next-week 0)))
    (format-time-string "%U"  monday-midnight-next-week t)))

(defun aleks/monday-this-week (&optional origin)
  "Returns the date of the week's monday relative to ORIGIN."
  (let ((start-date (if origin origin (calendar-current-date))))
    (calendar-gregorian-from-absolute
     (- (calendar-absolute-from-gregorian start-date)
        (aleks/calendar-day-of-week start-date)))))

(defun aleks/gregorian-relative-to (offset &optional origin)
  "Add OFFSET days to Monday in the week of ORIGIN (or this week) and return `(MM DD YYYY)'."
  (calendar-gregorian-from-absolute (+ offset (calendar-absolute-from-gregorian (aleks/monday-this-week origin)))))

(defun aleks/next-sprint-review-day (&optional origin)
  "Get the next sprint review (Wednesday in 2 weeks) from ORIGIN or today.

Returns a calendar date '(MM DD YYYY)."
  (calendar-gregorian-from-absolute
   (+ 2 14 (calendar-absolute-from-gregorian (aleks/monday-this-week origin)))))

(defun aleks/next-sprint-planning-day (&optional origin)
  "Get the next day after the sprint review from ORIGIN or today.

Returns a calendar date '(MM DD YYYY)."
  (calendar-gregorian-from-absolute
   (+ 1 (calendar-absolute-from-gregorian
         (aleks/next-sprint-review-day origin)))))

(defun aleks/org-active-timestamp-from-gregorian (date &optional time)
  "Formats an active org-timestamp from DATE and TIME.

DATE is the format of `calendar-current-date' time is a list
'(HH MM) in 24-hour format."
  (let ((seconds (if time
                     (+ (* 60 (nth 1 time)) (* 3600 (car time)))
                   0)))
    (format-time-string
     (if (= seconds 0) "<%Y-%m-%d %a>" "<%Y-%m-%d %a %H:%M>")
     (calendar-time-from-absolute
      (calendar-absolute-from-gregorian date)
      seconds)
     t)))
#+end_src

** Cape
Pulled in because of a bug somewhere in LSP, see [[https://github.com/minad/corfu/issues/188][here]].

#+begin_src emacs-lisp
(use-package cape)
#+end_src

** Code Review

Rudimentary support for code reviews. Missing line numbers, syntax highlighting. The interface is somewhat clunky, but workable. Integrates with forge and thus magit.

#+begin_src emacs-lisp
  (use-package code-review
    :hook (code-review-mode . emojify-mode)
    :custom (code-review-auth-login-marker 'forge))
#+end_src

** Corfu (Completion)

An alternative to =company=.

#+begin_src emacs-lisp
(defun quit-corfu-and-exit-to-normal-mode ()
  (interactive)
  (corfu-quit))

(use-package corfu
  :custom
  (corfu-auto t)
  (corfu-preselect 'prompt)
  (corfu-auto-delay 0.0)
  (corfu-auto-prefix 0)
  (corfu-quit-no-match 'separator)
  (completion-styles '(basic))
  (corfu-cycle t)
  :bind
  (:map corfu-map
        ("TAB" . corfu-next)
        ([tab] . corfu-next)
        ("S-TAB" . corfu-previous)
        ("<escape>" . quit-corfu-and-exit-to-normal-mode)
        ([backtab] . corfu-previous))
  :init
  (global-corfu-mode))

(use-package kind-icon
  :after corfu
  :custom
  (kind-icon-default-face 'corfu-default)
  :config
  (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

(use-package emacs
  :init
  (setq completion-cycle-threshold 3)
  (setq read-extended-command-predicate
        #'command-completion-default-include-p))
#+end_src

** Consult

#+begin_src emacs-lisp
  (use-package consult)
#+end_src

** Copilot
Github Co-Pilot support. It has no hook, I enable it on an as-need basis. The keychord for accepting completions mimics the one in Fish shell for accepting history items. It's muscle memory, and they look almost the same.

#+begin_src emacs-lisp
(use-package copilot
 :straight (:host github :repo "zerolfx/copilot.el" :files ("dist" "*.el"))
 :general (:definer 'minor-mode :states 'insert :keymaps 'copilot-mode
                    "C-f" 'copilot-accept-completion
                    "C-M-f" 'copilot-accept-completion-by-word))
#+end_src

** Diff-hl

Display git diff hint in the gutter.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :hook (magit-post-refresh . diff-hl-magit-post-refresh)
    :config (global-diff-hl-mode)
    :custom (diff-hl-side 'right))
#+END_SRC

** Editorconfig

Read =.editorconfig= files and adjust settings correspondingly.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+END_SRC

** Embark

#+begin_src emacs-lisp
  (use-package embark
    :bind (("C--" . embark-act)
           ("C-\\" . embark-dwim)
           ("C-h B" . embark-bindings)))
#+end_src

There's a package that allows using embark commands in consult.

#+begin_src emacs-lisp
  (use-package embark-consult
    :after (embark consult)
    :hook (embark-collect-mode . consult-preview-at-point-mode))
#+end_src

** Emojis

You know you want it, too. ðŸ˜¼ Using =emojify= mostly for Emoji insertion. Display via Noto Color Emoji font. Enable Emojify mode for github style emojis in Forge Post mode.

#+begin_src emacs-lisp
(set-fontset-font t 'symbol "Noto Color Emoji")
(set-fontset-font t 'symbol "Symbola" nil 'append)

(use-package emojify
  :hook (forge-post-mode . emojify-mode))
#+end_src

** Evil
#+begin_src emacs-lisp
(use-package evil
  :hook (after-init . evil-mode)
  :init
  (setq evil-want-keybinding nil
        evil-want-integration t)
  :custom
  (evil-want-Y-yank-to-eol t)
  (evil-move-beyond-eol t)
  (evil-undo-system 'undo-redo)
  (evil-want-C-d-scroll nil) ; C-u does nothing anyway
  :general
  (:states 'normal
           "RET" 'save-buffer
           "g b" 'bury-buffer))

(use-package evil-collection
  :after evil
  :custom (forge-add-default-bindings nil)
  :config (evil-collection-init '(calendar dired calc ediff magit corfu edebug eglot eldoc elisp-mode elisp-refs elisp-slime-nav embark emoji eshell eww flycheck flymake forge gnus grep help lsp-ui-imenu mu4e mu4e-conversation org org-present org-roam pdf pdf-view image racket-describe reftex restclient rg ripgrep selectrum tetris vc-dir vc-annotate vc-git vdiff vertico wgrep which-key )))

(use-package evil-surround
  :config
  (global-evil-surround-mode 1))
#+end_src

*** Dispatch with space/space menu.

#+begin_src emacs-lisp
(transient-define-prefix dispatch-space-menu () "This isn't documentation."
  [[
    "Buffers"
    ("b b" "consult buffer" consult-buffer)
    ("b k" "kill buffer" kill-this-buffer)
    "Projectile"
    ("p p" "switch project" projectile-switch-project)
    ("p f" "find file in project" projectile-find-file)
    ("p r" "ripgrep in project" consult-ripgrep)]
   ["Org"
    ("o a" "agenda" org-agenda)
    ("o c o" "clock out" org-clock-out)
    ("o c g" "clock goto" org-clock-goto)
    ("o c i" "clock in" org-clock-in)
    ("o c c" "capture" org-capture)
    ("o p p" "present" org-present)
    ("o i j" "jira link" xjira-org-insert-link-to-issue)
    ("o i l" "insert link" org-insert-link)]
   ["Git"
    ("g s" "git status" magit-status)
    ("g b" "git blame" magit-blame)
    ("g f" "git find file" magit-find-file)]
   ["Other"
    ("e" "expand region" er/expand-region)
    ("x f" "find file" find-file)
    ("x e" "open eshell here" eshell-here)]])

(general-define-key
 :states 'normal
 "SPC" 'dispatch-space-menu)
#+end_src

** Expand Region

#+begin_src emacs-lisp
(use-package expand-region
  :straight (expand-region
             :host nil
             :branch "treesit-er"
             :repo "/home/aleks/src/expand-region.el"))
#+end_src

** Extract Issue Numbers from Branch
Insert the current ticket number if we're on a feature branch.

#+begin_src emacs-lisp
  (defun buffer-insert-at-end (string)
    "Insert STRING at the maximal point in a buffer."
    (save-excursion
      (goto-char (point-max))
      (end-of-line)
      (insert ?\n string)
      (unless (string-suffix-p "\n" string)
        (insert ?\n))))

  (defun get-knuth-number-from-string (string)
    "Return KNUTH issue number from STRING.
  Return nil if STRING does not contain a KNUTH issue.
  STRING may be nil."
    (if (and string (string-match "\\(KNUTH-[[:digit:]]\+\\)" string))
        (match-string 1 string)
      nil))

  (defun insert-knuth-ticket-number-from-branch ()
    "If we're on a KNUTH feature branch, insert the ticket number."
    (interactive)
    (let ((knuth (get-knuth-number-from-string (magit-get-current-branch))))
      (if (and knuth (not (buffer-line-matches-p (concat "^" knuth)))) (buffer-insert-at-end knuth))))

  (defun buffer-line-matches-p (needle)
    "Return t if the last line matches NEEDLE.
  Ignores comments"
    (save-excursion
      (goto-char 0)
      (search-forward-regexp needle nil 'noerror)))

  (add-hook 'git-commit-setup-hook 'insert-knuth-ticket-number-from-branch)
#+end_src

** Flycheck

#+BEGIN_SRC emacs-lisp
(use-package flycheck
  ;; setting the load path so flycheck knows about includes
  :custom (flycheck-emacs-lisp-load-path 'inherit)
  :config (global-flycheck-mode))
#+END_SRC

*** Correct dependencies in eldev projects
In order to be able to ~require~ things in Elisp projects using =eldev= and for =flycheck= to pick that up, we'll need this extension.

#+begin_src emacs-lisp
(use-package flycheck-eldev)
#+end_src

*** Checkdoc in org src edit buffers
=checkdoc= will insist on headers, footers, commentary sections etc. in all your elisp code, including code that's opened with =org-src-edit=, which makes no sense at all. The corresponding function is =checkdoc-comments= and it runs whenever =buffer-file-name= is set. Org src edit buffers do set a file name, so =checkdoc= happily checks their comments. There's no way to exclude just one kind of check, so we just disable checkdoc in =org-src-edit= buffers.

#+begin_src emacs-lisp
  (defun disable-checkdoc ()
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
  (add-hook 'org-src-mode-hook 'disable-checkdoc)
#+end_src

** Guess-Language

This guesses the language a text is in per-paragraph. This means that you can code switch in your prose writing without having half the text turn up bright red (and *with* functioning spell-check in all languages.)

#+begin_src emacs-lisp
(use-package guess-language
  :hook (text-mode . (lambda () (guess-language-mode 1)))
  :custom
  (guess-language-languages '(en de bg pl))
  (guess-language-langcodes '((en . ("en_GB" "English"))
                              (de . ("de_DE" "German"))
                              (bg . ("bg_BG" "Bulgarian"))
                              (pl . ("pl_PL" "Polish")))))
#+end_src

** LSP

Language Server Protocol support using =lsp-mode=. =read-process-output-max= is set so larger LSP JSON payloads can be processed by Emacs.

#+begin_src emacs-lisp
(use-package lsp-mode
  :hook (lsp-mode . lsp-enable-which-key-integration)
  :custom
  (read-process-output-max (* 5 1024 1024))
  ;(lsp-eslint-validate '("typescript" "svelte"))
  (lsp-rust-analyzer-server-display-inlay-hints t)
  (lsp-eldoc-render-all nil)
  (lsp-use-plists t)
  :bind (("M-RET" . lsp-execute-code-action)
         ("M-d" . lsp-ui-doc-glance)
         ("M-D" . lsp-ui-doc-show))
  :config
  (setq lsp-keymap-prefix "SPC"))
#+end_src

LSP Ui provides action overlays and other goodies, but can get somewhat intrusive.

#+begin_src emacs-lisp
(use-package lsp-ui
  :custom
  (lsp-ui-peek-always-show t)
  (lsp-ui-sideline-enable nil)
  (lsp-ui-doc-enable t)
  :general
  (:states 'normal
           "g r" 'lsp-ui-peek-find-references)
  :config
  (define-key lsp-ui-peek-mode-map "j" 'lsp-ui-peek--select-next)
  (define-key lsp-ui-peek-mode-map "k" 'lsp-ui-peek--select-prev)
  (define-key lsp-ui-peek-mode-map "J" 'lsp-ui-peek--select-next-file)
  (define-key lsp-ui-peek-mode-map "K" 'lsp-ui-peek--select-prev-file))
#+end_src

Finally, treemacs can help orientation

#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :hook (lsp-mode . lsp-treemacs-sync-mode))
#+end_src

** Magit

The best =git= porcelain ever.

#+begin_src emacs-lisp
(use-package magit
  :bind (("C-c G g" . magit-status)
         ("C-c G G" . magit-status)
         ("C-c G s" . magit-status)
         ("C-c G b" . magit-blame))
  :custom
  (magit-save-repository-buffers 'dontask)
  :config
  (transient-append-suffix 'magit-branch '(2 2 2) '("o" "from current task" aleks/create-branch-from-current-task)))
#+end_src

Integration for Github.

#+begin_src emacs-lisp
  (use-package forge
    :after magit)
#+end_src

*** Integration into org-mode

This allows creating a branch from the currently clocked in org-mode task. Using this alongside my Jira-Bindings allows me to create org-headlines from Jira tickets, clock in, then create a branch for that ticket.

#+begin_src emacs-lisp
  (defun aleks/branchify (string)
    "Make STRING a valid git branch name."
    (replace-regexp-in-string
     (rx (or (any "~" "^" ":" "\\") (seq bos "\.") "\.\." (seq "/" eos) (seq "\.lock" eos)))
     "" (string-replace " " "-" string)))

  (defun aleks/create-branch-from-current-task ()
    "Create a new git branch using the current org task's name."
    (interactive)
    (if (and (boundp 'org-clock-current-task) org-clock-current-task)
        (let ((branch-name (aleks/branchify org-clock-current-task)))
          (magit-branch-and-checkout branch-name (magit-read-starting-point "Create and checkout branch starting at"))
          (message "Created and checked out `%s'" branch-name))
      (message "No current task.")))
#+end_src

** Move File and Buffer

Adapted from this [[https://stackoverflow.com/questions/384284/how-do-i-rename-an-open-file-in-emacs][StackOverflow answer]]. This lets you rename the current buffer and file at the same time.

#+begin_src emacs-lisp
(defun rename-file-and-buffer ()
  "Renames both current buffer and file it's visiting.

It's just an alias now to the built-in `rename-visited-file'."
  (interactive)
  (rename-visited-file))
#+end_src

** Mu4e

The context definitions are in =private.org=.

=set-from-line= manages identities: always answer with the =to:= email address when it's to one of my private email addresses. Manage mailing list identities separately (I know of no automatic way, unfortunately.)

#+begin_src emacs-lisp
  (defun aleks/set-from-line ()
    "Set From: address based on To: address of original email.  Also set mailing list addresses."
    (when mu4e-compose-parent-message
      (cond
       ((mu4e-message-contact-field-matches mu4e-compose-parent-message :to "aleks.bg")
        (setq user-mail-address (plist-get (car (mu4e-message-field mu4e-compose-parent-message :to)) :email)))
       ((mu4e-message-contact-field-matches mu4e-compose-parent-message :list-post "emacs-orgmode")
        (setq user-mail-address "org@list.aleks.bg")))))

  (defun aleks/sequence-to-directory (&rest args)
    "Turn ARGS into a valid path, each item a segment."
    (mapconcat #'file-name-as-directory args nil))

  (use-package mu4e
    :commands mu4e
    :straight (:host github
                     :files ("build/mu4e/*.el")
                     :branch "v1.8.14"
                     :repo "djcb/mu"
                     :pre-build (("./autogen.sh") ("ninja" "-C" "build")))
    :config
    (require 'mu4e-contrib)
    (aleks/load-org-file "private.org")
    (add-to-list 'mu4e-headers-actions '("in browser" . mu4e-action-view-in-browser) t)
    (add-to-list 'mu4e-view-actions '("in browser" . mu4e-action-view-in-browser) t)
    (require 'org-mu4e)
    :hook
    (mu4e-view-mode . aleks/disable-show-trailing-whitespace)
    (mu4e-headers-mode . aleks/disable-show-trailing-whitespace)
    (mu4e-compose-mode . aleks/set-from-line)
    :custom
    (mu4e-mu-binary
     (concat
      (aleks/sequence-to-directory (getenv "HOME") ".emacs.d" "straight" "repos" "mu" "build" "mu")
      "mu"))
    (shr-color-visible-luminance-min 80)
    (mail-user-agent 'mu4e-user-agent)
    (mu4e-update-interval 60)
    (message-send-mail-function 'smtpmail-send-it)
    (mu4e-use-fancy-chars t)
    (mu4e-attachment-dir "~/Downloads")
    (mu4e-view-show-images t)
    (mu4e-headers-fields '((:human-date . 25)
                           (:flags . 6)
                           (:from . 22)
                           (:thread-subject . nil))))
#+END_SRC

** Multiple Cursors

#+begin_src emacs-lisp
  (use-package multiple-cursors)
#+end_src

** Pair Programmer Mode

A mode that eases working with people on code together. It turns on line numbers and also adds a =Co-Authored-By= stanza to every git commit while it is active.

#+begin_src emacs-lisp
  (defvar pair-programming-mode--pair-programmer nil
    "The current pair programmer as (name email)")

  (defun enable-pair-programming-mode ()
    "Set visuals for pair programming mode and prompt for your buddy."
    (global-display-line-numbers-mode 1)
    (let ((pair-programmer (git-commit-read-ident nil)))
      (setq pair-programming-mode--pair-programmer pair-programmer)
      (message (concat "Pair programming with " (car pair-programmer)))))

  (defun disable-pair-programming-mode ()
    "Disable pair programming visuals and settings."
    (setq pair-programming-mode--pair-programmer nil)
    (global-display-line-numbers-mode -1)
    (message "PP mode disabled"))

  (define-minor-mode pair-programming-mode
    "Toggle Pair Programming Mode.
  This prompts for a pair programmer from your current git commit history.
  When you commit with (ma)git, the pair programmer is inserted as a co-author.
  Additionally, line number mode is enabled."
    :group 'pair-programming
    :global t
    :lighter " PP"
    (if pair-programming-mode
        (enable-pair-programming-mode)
      (disable-pair-programming-mode)))

  (defun insert-pair-programmer-as-coauthor ()
    "Insert your pair programer into the current git commit."
    (when (and pair-programming-mode git-commit-mode)
      (pcase pair-programming-mode--pair-programmer
        (`(,name ,email) (git-commit-insert-header "Co-authored-by" name email))
        (_ (error "No pair programmer found or malformed content.")))))

  (add-hook 'git-commit-setup-hook 'insert-pair-programmer-as-coauthor)
#+end_src

** Parentheses

Highlight parentheses in different colours according to their nesting level.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Smartparens to make handling parentheses easier.

#+begin_src emacs-lisp
(use-package smartparens
  :init
  (require 'smartparens-config)
  :general
  (:definer 'minor-mode :states 'insert :keymaps 'smartparens-mode
            "C-=" 'sp-forward-slurp-sexp
            "C-/" 'sp-forward-barf-sexp)
  :config
  (smartparens-global-mode 1)
  (show-smartparens-global-mode 1)
  :custom
  (sp-wrap-repeat-last 2) ;; repeat wrap with different pair
  (smartparens-strict-mode 1)
  (sp-show-pair-delay 0))
#+end_src

** Projectile
I haven't configured =projectile= to use =selectrum=, but it's working alright for now.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :bind (("C-c p p" . projectile-switch-project)
           ("C-c p b" . projectile-switch-to-buffer)
           ("C-c p f" . projectile-find-file))
   :config
    (projectile-mode +1))
#+END_SRC

** Pulsar
Protesilaos' take on beacon-mode is somewhat more lightweight and seems to be less error-prone.

#+begin_src emacs-lisp
  (use-package pulsar
    :custom
    (pulsar-pulse t)
    (pulsar-delay 0.025)
    (pulsar-iterations 10)
    (pulsar-face 'pulsar-generic)
    (pulsar-highlight-face 'pulsar-yellow)
    :config
    (pulsar-global-mode 1))
#+end_src

** Ripgrep

Near-instant full-text-search across projects.

#+BEGIN_SRC emacs-lisp
  (use-package rg)
#+END_SRC

** Selection

=helm= â†’ =ivy= â†’ =selectrum= â†’ =vertico=. You'd think something as simple as selecting which command to issue would be easy. Well, seems like the design space is unlimited.


Try out =selectrum= as an alternative to =ivy=.

#+begin_src emacs-lisp
(use-package vertico
  :straight (vertico :type git :host github :repo "emacs-straight/vertico")
  :init
  (vertico-mode)
  :custom
  (vertico-cycle t))

(use-package vertico-directory
  :straight (vertico-directory :type git :host github :repo "emacs-straight/vertico" :files ("extensions/*.el"))
  :after vertico
  :bind (:map vertico-map
              ("RET" . vertico-directory-enter)
              ("DEL" . vertico-directory-delete-char)
              ("M-DEL" . vertico-directory-delete-word))
  :hook (rfn-eshadow-update-overlay . vertico-directory-tidy))

(use-package savehist
  :init
  (savehist-mode))
#+end_src

I've taken this verbatim from Vertico's readme. To be honest, I don't quite understand what these do.

#+begin_src emacs-lisp
  ;; A few more useful configurations...
  (use-package emacs
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; We display [CRM<separator>], e.g., [CRM,] if the separator is a comma.
    (defun crm-indicator (args)
      (cons (format "[CRM%s] %s"
                    (replace-regexp-in-string
                     "\\`\\[.*?]\\*\\|\\[.*?]\\*\\'" ""
                     crm-separator)
                    (car args))
            (cdr args)))
    (advice-add #'completing-read-multiple :filter-args #'crm-indicator)

    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
    (setq enable-recursive-minibuffers t))
#+end_src

Quicker matching with =orderless=

#+begin_src emacs-lisp
  (use-package orderless
    :init
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (setq orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch)
    ;;       orderless-component-separator #'orderless-escapable-split-on-space)
    (setq completion-styles '(orderless partial-completion basic)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))
#+end_src

Use =prescient= for sorting options by /frecency/:

#+begin_src emacs-lisp
  (use-package prescient
    :config
    (prescient-persist-mode +1))

  (use-package vertico-prescient
    :after vertico
    :init (vertico-prescient-mode +1))
#+end_src

Add documentation to each selection entry if possible.

#+begin_src emacs-lisp
  (use-package marginalia
    :bind (:map minibuffer-local-map ("M-a" . marginalia-cycle))
    :init
    (marginalia-mode))
#+end_src

** Smerge

Awesome shortcuts to do complicated 3-way-merges with =git=.

** Snippets

Snippets live in version control under the Emacs directory.

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1)
    :custom
    (yas-snippet-dirs '("~/config/emacs/snippets")))
#+end_src

** String Inflection

Useful to cycle between =CamelCase=, =snake_case=, etc. No keybindings, I just call it with =M-x=.

#+begin_src emacs-lisp
  (use-package string-inflection)
#+end_src

** Treemacs

A bit too visual for my taste, but sometimes comes in handy. Let's see if it's worth keeping it around

#+begin_src emacs-lisp
  (use-package treemacs
    :defer t)
#+end_src

And sync between projectile and treemacs

#+begin_src emacs-lisp
  (use-package treemacs-projectile
    :after (treemacs projectile))
#+end_src

And let treemacs know about staging files in git

#+begin_src emacs-lisp
  (use-package treemacs-magit
    :after (treemacs magit))
#+end_src

** Treesitter

Treesitter is now built-into Emacs 29.

First, compile tree-sitter and update your LD cache:

#+begin_src shell
  git clone https://github.com/tree-sitter/tree-sitter
  cd tree-sitter
  make all
  sudo make install
  sudo ldconfig
#+end_src

Then download some grammars. There's a little helper script:

#+begin_src shell
  git clone https://github.com/casouri/tree-sitter-module
  cd tree-sitter-module
  ./batch.sh
#+end_src

Then compile Emacs with ~--with-tree-sitter~. Finally, point ~treesit-extra-load-path~ to the above =tree-sitter-module= project.

#+begin_src emacs-lisp
  (require 'treesit)
  (setq treesit-extra-load-path
        (list "~/var/src/tree-sitter-module/dist"))
#+end_src

** Which-Key

=which-key= shows hints after pressing a prefix key. Greatly aids discoverability.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+END_SRC

** Whitespace

Switch on highlighting of trailing white space, and provide a facility to turn it off on a per-mode base, as for some modes it's not useful.

#+begin_src emacs-lisp
(custom-set-variables '(show-trailing-whitespace t))

(defun aleks/disable-show-trailing-whitespace ()
    "Disable trailing whitespace."
    (setq show-trailing-whitespace nil))

(add-hook 'calendar-mode-hook 'aleks/disable-show-trailing-whitespace)
(add-hook 'embark-collect-mode-hook 'aleks/disable-show-trailing-whitespace)
#+end_src

** XJira

An integration for Jira I wrote. The only thing it does is offer a way to capture Jira issues in org-capture templates.

#+begin_src emacs-lisp
  (use-package xjira
    :straight (xjira :type git :host github :repo "adimit/xjira"))
#+end_src

The authorisation and host variables are set in =private.org=.
