* Early Initialisation

Everything that is in here needs to happen early.

** Straight
The initialization code for =straight.el= that lives [[https://github.com/raxod502/straight.el#getting-started][in the straight.el readme]] is already loaded in =init.el=.

Note that you also have to place the following in your =early-init.el=:

#+begin_src emacs-lisp :tangle no
  (setq package-enable-at-startup nil)
#+end_src

** Use-Package

For general package management use use-package, and instruct it to always use straight.

#+begin_src emacs-lisp
  (straight-use-package 'use-package)
  (custom-set-variables
   '(straight-use-package-by-default t))
#+end_src

** Environment

Slurp the shell environment into Emacs when started as a daemon.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :custom exec-path-from-shell-variables
    '("PATH" "MANPATH"))

  (when (daemonp)
    (exec-path-from-shell-initialize))
#+end_src

** Evil

We set =evil-want-keybinding= to =nil= for =evil-collection=. I rarely use prefix arguments, and if I do, I'm probably in normal mode, whereas =C-u= is a very useful insert mode shortcut. Finally, we're using Emacs 28's new =undo-redo= instead of relying on outside packages.

#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-keybinding nil
          evil-want-integration t)
    :config
    (evil-mode 1)
    :custom
    (evil-want-C-u-delete t)
    (evil-want-Y-yank-to-eol t)
    (evil-undo-system 'undo-redo))
#+end_src

** General
=general= seems rather unmaintained, but it still is the most convenient way to set up key bindings. This needs to be very high up so that every following =use-package= declaration can make use of =:general=.

#+begin_src emacs-lisp
  (use-package general
    :after evil
    :config
    (general-define-key
     :states 'normal
     "RET" 'save-buffer
     :states 'motion
     ";" 'evil-ex
     ":" 'evil-repeat-find-char)
    :config
    (general-create-definer
     aleks/global-leader
     :prefix ",")
    (general-create-definer
     aleks/local-leader
     :prefix ", ."))
#+end_src

* Emacs

Tweak various aspects of Emacs' visuals and behaviour.

** Appearance & Behaviour

Some basic appearance & behaviour settings

#+begin_src emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
  (set-face-attribute hl-line-face nil :underline nil)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (custom-set-variables
   '(inhibit-startup-screen t)
   '(indent-tabs-mode nil)
   '(initial-scratch-message "")
   '(mouse-yank-at-point t))
#+end_src

** Auth
This uses =pass= for all auth storage, including =mu4e= and =ghub=. If there are problems remember =(setq auth-source-debug t).=

#+begin_src emacs-lisp
  (auth-source-pass-enable)
#+end_src

Let Emacs query the pass phrase instead of an external pinentry dialogue.

#+begin_src emacs-lisp
  (customize-set-variable 'epg-pinentry-mode 'loopback)
#+end_src

** Backups

No files with =~= everywhere. Prevent creation of lockfiles, as that confuses some watch tasks (notably webpack dev server.)

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(backup-directory-alist `(("." . "~/.saves")))
   '(create-lockfiles nil))
#+END_SRC

** Calendar
Calendar is set up for European style display (Monday starts week) and manual location of Tübingen, Germany (for sunrise/sunset).
Tübingen Hbf is: =48.516738, 9.055493=

#+BEGIN_SRC emacs-lisp
  (defvar holiday-baden-württemberg-holidays
    '((holiday-fixed 1 1 "Neujahr")
      (holiday-fixed 1 6 "Heilige Drei Könige")
      (holiday-fixed 5 1 "Tag der Arbeit")
      (holiday-fixed 10 3 "Tag der deutschen Einheit")
      (holiday-fixed 11 1 "Allerheiligen")
      (holiday-fixed 12 25 "Erster Weihnachtsfeiertag")
      (holiday-fixed 12 26 "Zweiter Weihnachtsfeiertag")
      (holiday-easter-etc -2 "Karfreitag")
      (holiday-easter-etc +1 "Ostermontag")
      (holiday-easter-etc +39 "Christi Himmelfahrt")
      (holiday-easter-etc +50 "Pfingstmontag")
      (holiday-easter-etc +60 "Fronleichnam")))
  
  (use-package calendar
    :defer t
    :custom
    (calendar-week-start-day 1)
    (calendar-latitude 48.516738)
    (calendar-longitude 9.055493)
    (calendar-location-name "Tübingen, Germany")
    (calendar-holidays
     (append holiday-solar-holidays
             holiday-baden-württemberg-holidays))
    (calendar-date-style 'european)
    (calendar-time-display-form
     '(24-hours ":"
                minutes
                (if time-zone (concat " (" time-zone ")")))))
  
#+END_SRC

Here's a function that returns whether it's currently dark outside, so you don't have to look.

#+begin_src emacs-lisp
  (defun aleks/is-it-dark-p ()
    "Return t if it's dark outside, otherwise nil.

  Will look at the `current-time' and calculate sunset and sunrise times
  according to `calendar-longitude' and `calendar-latitude' using
  `solar-sunrise-sunset'so make sure you've set your location."
    (require 'solar)
    (let* ((solar (solar-sunrise-sunset (calendar-current-date)))
	 (sunrise (car (car solar)))
	 (sunset (car (car (cdr solar))))
	 (time (decode-time (current-time)))
	 (hour (nth 2 time))
	 (minute (nth 1 time))
	 (minute-fraction (/ minute 60.0))
	 (time-decimal (+ hour minute-fraction)))
    (or (> time-decimal sunset) (< time-decimal sunrise))))
#+end_src

** Emacs-Server

Enable emacs server mode.

#+begin_src emacs-lisp
  (server-mode)
#+end_src

There are two shell aliases that help with server mode:

#+begin_src shell
  alias ec=emacsclient -n
  alias ecc=emacsclient -cn
#+end_src

=ecc= opens another frame, and =ec= just re-uses an existing frame.
** Font

Instead of using a package like =org-variable-pitch-mode=, the
following definition takes care of setting up which parts of
=org-mode= are fixed pitch.

#+begin_src emacs-lisp
  (defun aleks/set-org-mode-fixed-pitch-faces ()
    (mapc (lambda (face) (set-face-attribute face nil :inherit 'fixed-pitch))
          `(org-block
            org-special-keyword
            org-drawer
            org-todo
            org-done
            org-priority
            org-checkbox
            org-block-end-line
            org-block-begin-line
            org-table org-verbatim)))

  (with-eval-after-load "org"
   (aleks/set-org-mode-fixed-pitch-faces))
#+end_src

And here's a function to set the different faces.

#+begin_src emacs-lisp
  (defun aleks/set-light-mode-faces ()
      "Set the faces for light mode."
      (custom-set-faces
       '(variable-pitch ((t (:family "Bitter" :height 170))))
       '(fixed-pitch ((t (:family "Fira Code" :height 160))))
       '(default ((t (:family "Fira Code" :height 160))))))
#+end_src

These are triggered after [[Theme]] selection.

** Global Keybindings

Using the global leader, these are valid everywhere.

#+begin_src emacs-lisp
  (aleks/global-leader
    :states 'normal
    :keymaps 'override
    "" nil ; make sure global-leader can be used as a prefix key
    "b" 'switch-to-buffer
    "f" 'find-file
    "c" 'org-capture
    "a" 'org-agenda)
#+end_src



** Mime Types

Handle specific file types. This is used especially by =ein-python=.

#+begin_src emacs-lisp
  (custom-set-variables
   '(mailcap-user-mime-data
     '((viewer . "eog %s")
       (type . "image/.*"))))
#+end_src

** Mode Line

An experimental minimalist modeline. I've always been too lazy to write my own.

#+begin_src emacs-lisp
  (use-package nano-modeline
    :straight (:type git :host github :repo "rougier/nano-modeline")
    :config (nano-modeline-mode)
    :custom (nano-modeline-position 'bottom))
#+end_src

** Text buffers

When reading text, the buffer shouldn't get too wide. Olivetti mode takes care of that.

#+begin_src emacs-lisp
  (use-package olivetti)
#+end_src

Text mode buffers have spell check enabled, are narrowed, and use variable pitch and word wrap.

#+begin_src emacs-lisp
  (defun aleks/text-mode-hook ()
    (flyspell-mode)
    (visual-line-mode)
    (variable-pitch-mode)
    (olivetti-mode))
  
  (add-hook 'text-mode-hook 'aleks/text-mode-hook)
#+end_src

** Theme

Use Prot's awesome Modus theme, vivendi by default. They're built-in
to Emacs now, but we're loading the latest version here.

#+begin_src emacs-lisp
  (use-package modus-themes
    :init
    ;; Add all your customizations prior to loading the themes
    (setq modus-themes-italic-constructs t
          modus-themes-bold-constructs t
          modus-themes-region '(bg-only no-extend)
          modus-themes-scale-headings t
          modus-themes-slanted-constructs t
          modus-themes-scale-1 1.1
          modus-themes-scale-2 1.2
          modus-themes-scale-3 1.3
          modus-themes-scale-4 1.4
          modus-themes-scale-5 1.5)

    ;; Load the theme files before enabling a theme
    (modus-themes-load-themes)
    :config
    (modus-themes-load-vivendi)
    (aleks/set-light-mode-faces))
#+end_src

** Utility functions

*** Append to =org-babel-load-languages=

I'd like to append to =org-babel-load-languages= right from a =use-package= =:config= declaration, to keep configuration neat. The following macro loads the Org Babel definition and appends it to =org-babel-load-languages=, instead of overwriting the content of the variable. Accepts a list in the form ='((R . t))=.

#+begin_src emacs-lisp
  (defmacro aleks/org-babel-load-languages (list)
    "Load the language definitions in LIST and add them to `org-babel-load-languages'."
    `(org-babel-do-load-languages
      'org-babel-load-languages
      (append org-babel-load-languages ,list)))
#+end_src

* Major Modes

A list of supported major modes and their configuration.

** CSS
#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css$"
    :custom (css-indent-offset 2))
  (use-package scss-mode
    :mode ("\\.scss$" "\\.sass$"))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :mode "\\.[ct]sv$")
#+END_SRC

** Docker

#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode :mode "Dockerfile")
#+END_SRC

** Fish

#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode "\\.fish$")
#+END_SRC

** Graphql

#+BEGIN_SRC emacs-lisp
  (use-package request)

  (use-package graphql-mode
    :load-path "~/src/graphql-mode/"
    :mode "\\.graphql$"
    :custom (graphql-indent-level 4))
#+END_SRC

** Graphviz

Add =graphviz-dot-mode= to facilitate writing of graphviz graphs

#+begin_src emacs-lisp
  (use-package graphviz-dot-mode)
#+end_src

Also add =ob-dot= to embed graphs in Org mode

#+begin_src emacs-lisp
  (aleks/org-babel-load-languages '((dot . t)))
#+end_src

** Groovy

#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :mode "build\\.gradle" "\\.groovy$")
#+END_SRC


** Haskell

#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs$")
#+END_SRC

** Json
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json$"
    :config
    (add-to-list 'flycheck-disabled-checkers 'json-python-json))
#+END_SRC

** Kotlin

Only basic support :(

#+BEGIN_SRC emacs-lisp
  (use-package kotlin-mode
    :mode "\\.kt$")
#+END_SRC

** Ledger

The function =browse-amazon-history-at-point= is useful to get to the Amazon order number from the bank statement itself. Helps with categorisation.

#+BEGIN_SRC emacs-lisp
  (defun browse-amazon-history-at-point ()
    "Open amazon.de order history.  The search term is `thing-at-point'."
    (interactive)
    (browse-url (concat "https://www.amazon.de/gp/your-account/order-history/?search=" (thing-at-point 'symbol 'no-props))))

  (use-package ledger-mode
    :mode "hledger\\.journal$" "\\.ledger$"
    :general
    (aleks/local-leader :states 'normal :keymaps 'ledger-mode-map
             "a" 'browse-amazon-history-at-point
             "p" 'browse-paypal-history-at-point))

  (use-package flycheck-ledger
    :after flycheck ledger-mode)
#+END_SRC

** Lua

#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode "\\.lua$"
    :interpreter "lua")
#+END_SRC

** Markdown

#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md$"
    :custom (markdown-fontify-code-blocks-natively t))
#+END_SRC

** Org

Loading org already happened in =init.el=.

*** Agenda

The most important files get their own variables.

#+begin_src emacs-lisp
  (defcustom org-directory (concat (file-name-as-directory (getenv "HOME")) "org") "Org directory.")
  (defcustom my-org-main-file (concat (file-name-as-directory org-directory) "main.org") "Personal Org agenda file.")
  (defcustom my-org-work-file (concat (file-name-as-directory org-directory) "work.org") "Professional Org agenda file.")
#+end_src

Add diary and agenda files.

#+begin_src emacs-lisp
  (custom-set-variables
   '(org-agenda-include-diary t)
   '(org-agenda-files `(,my-org-main-file ,my-org-work-file))
   '(diary-file (concat (file-name-as-directory org-directory) "diary")))
#+end_src

*** Babel

Tangle every block by default.

#+begin_src emacs-lisp
  (add-to-list 'org-babel-default-header-args '(:tangle . "yes"))
#+end_src

Redisplay images after code block evaluation. Handy if the result of your computation is an image: it'll pop up immediately.

#+begin_src emacs-lisp
  (add-hook 'org-babel-after-execute-hook 'org-redisplay-inline-images)
#+end_src

*** Capture

Capture templates:

#+begin_src emacs-lisp
  (defun join-lines (strings)
    "Join STRINGS with newlines."
    (string-join strings "\n"))
  (customize-set-variable
   'org-capture-templates
   `(("c" "Add to today" entry
      (file+regexp my-org-main-file "Week [0-9][0-9]?")
      ,(join-lines
        '("* TODO %?"
          "SCHEDULED: %t"
          ":PROPERTIES:"
          ":CREATED: %U"
          ":END:"
          "")))
     ("W" "Plan Week" entry (file my-org-main-file)
      ,(join-lines
        '("* Week %(aleks/get-next-week-number)"
          "** TODO Prepare Cat Meds"
          "** TODO Clean Bathroom"
          "** TODO Weekly Review"
          "** TODO Vacuum & Mop"
          "** TODO Make Yogurt"
          "** TODO Feed Sourdough")))
     ("s" "Add task to sprint" entry
      (file+headline my-org-work-file "Tasks")
      ,(join-lines
        '("* TODO %?"
          "SCHEDULED: %t"
          ":PROPERTIES:"
          ":CREATED: %U"
          ":REFERENCE: %f"
          ":END:"
          ""
          "%i")))
     ("j" "Add MP Jira ticket" entry
      (file+headline my-org-work-file "Tasks")
      ,(join-lines
        '("* TODO %(xjira-org-capture-issue \"KNUTH\") %(xjira-get 'issue) %(xjira-get 'title)"
          "SCHEDULED: %t"
          ":PROPERTIES:"
          ":REFERENCE: %(eval xjira-host)/browse/%(xjira-get 'issue)"
          ":Reporter: %(xjira-get 'reporter)"
          ":Parent: [[%(eval xjira-host)/browse/%(xjira-get 'parent)][%(xjira-get 'parent-title)]]"
          ":END:"
          ""
          "%(xjira-get 'description)")))
     ("m" "Add meeting" entry
      (file+headline my-org-work-file "Meetings")
      ,(join-lines
        '("* MEET %?"
          "SCHEDULED: %^T"
          ":PROPERTIES:"
          ":REFERENCE:"
          ":END:")))
     ("S" "Sprint" entry (file my-org-work-file)
      ,(join-lines
        '("* Sprint %^{Title}"
          "** Meetings"
          "*** MEET Sprint Review"
          "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-review-day) '(15 30))"
          "*** MEET Retro"
          "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(9 00))"
          "*** MEET Next sprint SP1"
          "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(10 00))"
          "*** MEET Next sprint SP2"
          "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/next-sprint-planning-day) '(13 00))"
          "** Tasks"
          "*** TODO Update Metrics"
          "SCHEDULED: %(aleks/org-active-timestamp-from-gregorian (aleks/monday-this-week (aleks/next-sprint-review-day)))"
          ":PROPERTIES:"
          ":REFERENCE: %(eval team-integration-metrics-sheet-link)"
          ":END:"
          "%i%?")))))
#+end_src

*** Citations

Only works with the new (as of summer 2021) org citation support.

#+begin_src emacs-lisp
  (defvar aleks/global-bibliography-files '("~/doc/lib/bib/main.bib"))
  (custom-set-variables
   '(org-cite-global-bibliography aleks/global-bibliography-files))
#+end_src

We install =citeproc= to get the CSL backend.

#+begin_src emacs-lisp
  (use-package citeproc
    :config
    (require 'oc-csl))
#+end_src

We set the export backend to biblatex for latex.

#+begin_src emacs-lisp
  (custom-set-variables
   '(org-cite-export-processors
     '((latex biblatex)
       (t csl))))
#+end_src

*** Contrib

=org-contrib= is its own repo now, so we need to make it available.

#+begin_src emacs-lisp
  (use-package org-contrib
    :config
    (require 'ox-confluence))
#+end_src

*** Customisation

And we set a lot of configuration options for org.

#+begin_src emacs-lisp
  (custom-set-variables
   '(org-tags-column 0) ; alignment broken with variable pitch
   '(org-confirm-babel-evaluate nil) ; don't prompt when evaluating
   '(org-startup-folded t)
   '(org-hide-emphasis-markers t)
   '(org-babel-confirm-evaluate nil)
   '(org-log-into-drawer t)
   '(org-image-actual-width nil) ; Take the width from ORG_ATTRs
   '(org-outline-path-complete-in-steps nil) ; use a flat list instead of hierarchichal steps
   '(org-refile-targets
     '((nil . (:maxlevel . 4)))) ; don't descend more than 4 levels when refiling
   '(org-footnote-section nil)) ; place footnotes in same section
#+end_src

*** Export

Enable export back ends not enabled by default.

#+begin_src emacs-lisp
  (require 'org)
  (customize-set-variable
   'org-export-backends (append org-export-backends '(md)))
#+end_src

*** Evil

The agenda is a pain with evil.

#+begin_src emacs-lisp
  (use-package evil-org
    :config
    (require 'evil-org-agenda)
    (evil-org-agenda-set-keys))
#+end_src

*** Indentation

Indent mode keeps leading spaces out of org text files.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook #'org-indent-mode)
#+end_src

*** Inline Latex

Render inline LaTeX fragments somewhat bigger, to match the font size.
#+begin_src emacs-lisp
  (plist-put org-format-latex-options :scale 2)
#+end_src

*** Keybindings
**** General

#+begin_src emacs-lisp
  (aleks/local-leader
    :states 'normal
    :keymaps 'org-mode-map
    "'" 'org-edit-special
    "i" 'org-insert-structure-template
    "o" 'org-open-at-point
    "h" 'org-promote-subtree
    "l" 'org-demote-subtree
    "a" 'org-archive-subtree
    "s" 'org-schedule
    "d" 'org-deadline
    "e" 'org-set-effort
    "c c" 'org-clock-in
    "c i" 'org-clock-in
    "c o" 'org-clock-out
    "c g" 'org-clock-goto
    "c x" 'org-clock-cancel)
#+end_src

**** Edit Special

A quicker shortcut for editing special environments in =org=.

#+begin_src emacs-lisp
  (aleks/global-leader :states 'normal :keymaps 'org-mode-map
    "'" 'org-edit-special)
#+end_src

Interaction with special edits.

#+begin_src emacs-lisp
  (general-define-key
   :states 'normal
   :definer 'minor-mode
   :keymaps 'org-src-mode
   "<return>" 'org-edit-src-exit
   "<backspace>" 'org-edit-src-abort)
#+end_src

*** Reveal

#+BEGIN_SRC emacs-lisp
  (use-package ox-reveal
    :custom
    (org-reveal-root "file:///home/aleks/src/talks/reveal.js-4.1.0")
    (org-reveal-hlevel 2))
  (use-package htmlize)
#+END_SRC

*** Visuals

Prettier lists, by substituting bullet points for list item markers.

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords
   'org-mode
   '(("^ *\\([-]\\) "
      (0 (prog1 () (compose-region
                    (match-beginning 1)
                    (match-end 1)
                    "•"))))))
#+END_SRC

This hides heading bullets for a cleaner look.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook
    (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '(" "))
    (org-fontify-whole-heading-line t)
    (org-pretty-entities t))
#+END_SRC

Org-appear allows easy editing of inline markup when it's hidden.

#+begin_src emacs-lisp
  (use-package org-appear
    :hook (org-mode . org-appear-mode)
    :custom
    (org-appear-autolinks t)
    (org-appear-autosubmarkers t)
    (org-appear-autoemphasis t)
    :straight (org-appear :type git
                :host github
                :repo "awth13/org-appear"))
#+end_src

** PlantUML

=plantuml-mode= doesn't seem actively developed, but then again, PlantUML isn't exactly the latest and greatest either.

#+begin_src emacs-lisp
  (use-package plantuml-mode
    :mode "\\.plantuml\\'"
    :custom
    (plantuml-executable-path "/usr/bin/plantuml")
    (plantuml-default-exec-mode 'executable)
    (org-plantuml-jar-path "/usr/share/plantuml/plantuml.jar")
    :init
    (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
    (org-babel-do-load-languages 'org-babel-load-languages '((plantuml . t))))
#+end_src

** Protobuf

For Google's =.proto= spec files

#+begin_src emacs-lisp
  (use-package protobuf-mode)

  (defconst aleks/protobuf-style
    '((c-basic-offset . 2)
      (indent-tabs-mode . nil)))

  (add-hook 'protobuf-mode-hook
    (lambda () (c-add-style "mp-protobuf-style" aleks/protobuf-style t)))
#+end_src

** Python

LSP support with MS's server:

#+begin_src emacs-lisp
  (use-package lsp-python-ms
    :custom (lsp-python-ms-auto-install-server t)
    :hook (python-mode . lsp))
#+end_src

Jupyter notebook support (mainly for org.)

#+begin_src emacs-lisp
  (use-package ein
    :custom
    (ein:output-area-inlined-images t)
    :config
    (aleks/org-babel-load-languages '((ein . t))))
#+end_src

Add =elpy=

#+begin_src emacs-lisp
  (use-package elpy
    :defer t
    :init
    (advice-add 'python-mode :before 'elpy-enable))
#+end_src

** R

#+begin_src emacs-lisp
  (use-package ess
    :config
    (aleks/org-babel-load-languages '((R . t))))
#+end_src

** REST

Rest client with org support.

#+begin_src emacs-lisp
  (use-package restclient
    :mode "\\.rest$")

  (use-package ob-restclient
    :after (restclient)
    :config
    (aleks/org-babel-load-languages '((restclient . t))))
#+end_src

** Rust

Rustic mode works well with =rust-analyzer=. Format on save is done with [[Apheleia]] via =rustfmt=.

#+begin_src emacs-lisp
  (use-package rustic
    :hook
    (rustic-mode . lsp)
    :custom
    (rustic-lsp-server 'rust-analyzer)
    (lsp-rust-server 'rust-analyzer)
    (lsp-rust-analyzer-server-command '("~/.local/bin/rust-analyzer")))
#+end_src

** Typescript

Syntax highlighting via tree-sitter.

#+begin_src emacs-lisp
  (use-package typescript-mode
    :hook
    (typescript-mode . lsp)
    :mode "\\.tsx?\\'"
    :custom
    (typescript-indent-level 2))
#+end_src

When looking up React functional components, LSP returns React type signatures from React's own definitions in addition to the definition of the component itself. I'm not terribly interested in those, so we filter them out with a crude heuristic (a certain verbatim type signature and file location).

LSP lacks a general entrypoint to filter these out. See [[https://github.com/emacs-lsp/lsp-mode/issues/2103][this issue]].

#+begin_src emacs-lisp
  (require 'cl-seq)
  (require 'eieio)
  (require 'xref)

  (defun aleks/xref-react-type-definition-p (item)
    "Return t if `item' is a React type definition."
    (and
     (string-match-p "ReactElement<any, any>" (xref-item-summary item))
     (string-suffix-p "@types/react/index.d.ts" (xref-file-location-file (xref-item-location item)))))

  (defun aleks/filter-react-type-definitions (items)
    "Remove React FunctionComponent type definitions from xref-items."
    (cl-remove-if #'aleks/xref-react-type-definition-p items))

  (advice-add 'lsp--locations-to-xref-items :filter-return #'aleks/filter-react-type-definitions)
#+end_src


** YAML

#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode :mode "\\.ya?ml$")
#+END_SRC

* Utilities

Various add-ons outside of major mode functionality and Emacs core functionality.

** Apheleia (Auto-format on save)
Use [[https://github.com/raxod502/apheleia][Apheleia]] for on-save-actions, e.g. =prettier=, =black=, =rustfmt=.

=rustfmt= isn't supported out of the box. I've opened a [[https://github.com/raxod502/apheleia/pull/45][PR]]. In the meantime, we define our own.

#+begin_src emacs-lisp
  (use-package apheleia
    :straight (apheleia :type git
                        :host github
                        :repo "raxod502/apheleia")
    :config
    (apheleia-global-mode +1)
    (add-to-list 'apheleia-formatters
                 '(rustfmt  . ("rustfmt" "--unstable-features" "--skip-children" "--quiet" "--emit" "stdout" file)))
    (add-to-list 'apheleia-mode-alist
                 '(rustic-mode . rustfmt)))
#+end_src

** Avy

Jump to arbitrary points in the buffer

#+begin_src emacs-lisp
  (use-package avy
    :custom (avy-all-windows 'all-frames)
    :general
    (:states 'normal
             "g l" 'avy-goto-line
             "g c" 'avy-goto-char))
#+end_src

** Beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :config
    (beacon-mode 1)
    :custom
    (beacon-blink-delay 0.15)
    (beacon-blink-duration 0.15))
#+END_SRC

** Calculate Sprints

A utility function to calculate the next sprint review's date (usually) from today.

Note that we have to wrap =calendar-day-of-week= even though I've already set =calendar-week-start-day= to =1=, because weekdays are always 0-indexed at Sunday.

#+begin_src emacs-lisp
  (require 'calendar)
  (require 'cal-dst)
  (require 'cal-iso)

  (defun aleks/calendar-day-of-week (arg)
    "Get the day of week for ARG, European style.

  0 for Monday, … 6 for Sunday."
    (let ((anglo-day-of-week (calendar-day-of-week arg)))
      (if (= 0 anglo-day-of-week)
          6
        (- anglo-day-of-week 1))))

  (defun aleks/get-next-week-number ()
    "Return next week's ISO week number, based on `calendar-current-date'."
    (let* ((monday (aleks/monday-this-week (calendar-current-date)))
           (monday-next-week (+ (calendar-absolute-from-gregorian monday) 7))
           (monday-midnight-next-week (calendar-time-from-absolute monday-next-week 0)))
      (format-time-string "%U"  monday-midnight-next-week t)))

  (defun aleks/monday-this-week (&optional origin)
    "Returns the date of the week's monday relative to ORIGIN."
    (let ((start-date (if origin origin (calendar-current-date))))
      (calendar-gregorian-from-absolute
       (- (calendar-absolute-from-gregorian start-date)
          (aleks/calendar-day-of-week start-date)))))

  (defun aleks/next-sprint-review-day (&optional origin)
    "Get the next sprint review (Wednesday in 2 weeks) from ORIGIN or today.

  Returns a calendar date '(MM DD YYYY)."
    (calendar-gregorian-from-absolute
     (+ 2 14 (calendar-absolute-from-gregorian (aleks/monday-this-week origin)))))

  (defun aleks/next-sprint-planning-day (&optional origin)
    "Get the next day after the sprint review from ORIGIN or today.

  Returns a calendar date '(MM DD YYYY)."
    (calendar-gregorian-from-absolute
     (+ 1 (calendar-absolute-from-gregorian
           (aleks/next-sprint-review-day origin)))))

  (defun aleks/org-active-timestamp-from-gregorian (date &optional time)
    "Formats an active org-timestamp from DATE and TIME.

  DATE is the format of `calendar-current-date' time is a list
  '(HH MM) in 24-hour format."
    (let ((seconds (if time
                       (+ (* 60 (nth 1 time)) (* 3600 (car time)))
                     0)))
      (format-time-string
       (if (= seconds 0) "<%Y-%m-%d %a>" "<%Y-%m-%d %a %H:%M>")
       (calendar-time-from-absolute
        (calendar-absolute-from-gregorian date)
        seconds)
       t)))
#+end_src

** Corfu (Completion)

An alternative to =company=.

#+begin_src emacs-lisp
  (use-package corfu
    :custom
    (corfu-auto t)
    (corfu-auto-delay 0.1)
    (corfu-auto-prefix 0)
    (corfu-quit-no-match 'separator)
    (completion-styles '(basic))
    :init
    (global-corfu-mode))

  (use-package kind-icon
    :after corfu
    :custom
    (kind-icon-default-face 'corfu-default)
    :config
    (add-to-list 'corfu-margin-formatters #'kind-icon-margin-formatter))

  (use-package emacs
    :init
    (setq completion-cycle-threshold 3)
    (setq read-extended-command-predicate
          #'command-completion-default-include-p))
#+end_src

** Consult

#+begin_src emacs-lisp
  (use-package consult
    :general
    (aleks/global-leader :states 'normal "b" 'consult-buffer))
#+end_src

** Diff-hl

Display git diff hint in the gutter.

#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :hook (magit-post-refresh . diff-hl-magit-post-refresh)
    :config (global-diff-hl-mode)
    :custom (diff-hl-side 'right))
#+END_SRC

** Editorconfig

Read =.editorconfig= files and adjust settings correspondingly.

#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+END_SRC

** Embark
#+begin_src emacs-lisp :tangle no
  (use-package embark
    :general
    ("C-<return>" 'embark-act)
    (aleks/local-leader 'normal "." 'embark-act))
#+end_src

** Emojis
You know you want it, too. 😼 Using =emojify= mostly for Emoji insertion. Display via Noto Color Emoji font. Enable Emojify mode for github style emojis in Forge Post mode.

#+begin_src emacs-lisp
  (set-fontset-font t 'symbol "Noto Color Emoji")
  (set-fontset-font t 'symbol "Symbola" nil 'append)
  
  (use-package emojify
    :hook (forge-post-mode . emojify-mode))
#+end_src

** Evil Collection

With crowd sourced bindings for various packages:

#+begin_src emacs-lisp
  (use-package evil-collection
    :init
    (setq evil-collection-outline-bind-tab-p t)
    :after evil
    :config
    (evil-collection-init
     '(calendar
       flycheck
       magit
       mu4e
       mu4e-conversation
       outline
       rg
       xref)))
#+end_src

** Evil Extensions

Surround bindings for text objects (e.g. =c s b [=.)

#+begin_src emacs-lisp
  (use-package evil-surround
    :config
    (global-evil-surround-mode t))
#+end_src

Swap text objects with one command.  (e.g. =g x w=)

#+begin_src emacs-lisp
  (use-package evil-exchange
    :config (evil-exchange-install))
#+end_src

** Extract Issue Numbers from Branch
Insert the current ticket number if we're on a =KNUTH= feature branch.

#+begin_src emacs-lisp
  (defun buffer-insert-at-end (string)
    "Insert STRING at the maximal point in a buffer."
    (save-excursion
      (goto-char (point-max))
      (end-of-line)
      (insert ?\n string)
      (unless (string-suffix-p "\n" string)
        (insert ?\n))))

  (defun get-knuth-number-from-string (string)
    "Return KNUTH issue number from STRING.
  Return nil if STRING does not contain a KNUTH issue.
  STRING may be nil."
    (if (and string (string-match "\\(KNUTH-[[:digit:]]\+\\)" string))
        (match-string 1 string)
      nil))

  (defun insert-knuth-ticket-number-from-branch ()
    "If we're on a KNUTH feature branch, insert the ticket number."
    (interactive)
    (let ((knuth (get-knuth-number-from-string (magit-get-current-branch))))
      (if (and knuth (not (buffer-line-matches-p (concat "^" knuth)))) (buffer-insert-at-end knuth))))

  (defun buffer-line-matches-p (needle)
    "Return t if the last line matches NEEDLE.
  Ignores comments"
    (save-excursion
      (goto-char 0)
      (search-forward-regexp needle nil 'noerror)))

  (add-hook 'git-commit-setup-hook 'insert-knuth-ticket-number-from-branch)
#+end_src

** Flycheck

#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config (global-flycheck-mode))
#+END_SRC

*** Checkdoc in org src edit buffers
=checkdoc= will insist on headers, footers, commentary sections etc. in all your elisp code, including code that's opened with =org-src-edit=, which makes no sense at all. The corresponding function is =checkdoc-comments= and it runs whenever =buffer-file-name= is set. Org src edit buffers do set a file name, so =checkdoc= happily checks their comments. There's no way to exclude just one kind of check, so we just disable checkdoc in =org-src-edit= buffers.

#+begin_src emacs-lisp
  (defun disable-checkdoc ()
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
  (add-hook 'org-src-mode-hook 'disable-checkdoc)
#+end_src

** Guess-Language

This guesses the language a text is in per-paragraph. This means that you can code switch in your prose writing without having half the text turn up bright red (and *with* functioning spell-check in all languages.)

Currently, only German and English are supported here, as I don't write much else with Emacs.

#+begin_src emacs-lisp
  (use-package guess-language
    :hook (text-mode . (lambda () (guess-language-mode 1)))
    :custom
    (guess-language-languages '(en de))
    (guess-language-langcodes '((en . ("en_GB" "English"))
                                (de . ("de_DE" "German")))))
#+end_src

** LSP

Language Server Protocol support using =lsp-mode=. =read-process-output-max= is set so larger LSP JSON payloads can be processed by Emacs.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :custom
    (read-process-output-max (* 1024 1024))
    (lsp-eslint-validate '("typescript" "svelte"))
    :general
    (:states
     'normal
     "M-RET" 'lsp-execute-code-action))
#+end_src

LSP Ui provides action overlays and other goodies, but can get somewhat intrusive.

#+begin_src emacs-lisp
  (use-package lsp-ui)
#+end_src

** Magit

The best =git= porcelain ever.

#+begin_src emacs-lisp
  (use-package magit
    :general
    (aleks/global-leader
      :states 'normal
      "g s" 'magit-status
      "g f" 'magit-file-dispatch
      "g b" 'magit-blame))
#+end_src

Integration for Github.

#+begin_src emacs-lisp
  (use-package forge
    :after magit)
#+end_src

** Move File and Buffer

Adapted from this [[https://stackoverflow.com/questions/384284/how-do-i-rename-an-open-file-in-emacs][StackOverflow answer]].

#+begin_src emacs-lisp
  (defun rename-file-and-buffer (new-name)
    "Renames both current buffer and file it's visiting to NEW-NAME."
    (interactive "sNew name: ")
    (let ((name (buffer-name))
          (filename (buffer-file-name)))
      (if (buffer-modified-p)
          (message "Buffer is modified, save it first.")
        (if (not filename)
            (message "Buffer '%s' is not visiting a file." name)
          (if (get-buffer new-name)
              (message "A buffer named '%s' already exists." new-name)
            (progn
              (rename-file filename new-name 1)
              (rename-buffer new-name)
              (set-visited-file-name new-name)
              (set-buffer-modified-p nil)))))))
#+end_src

** Mu4e

The context definitions are in =private.org=.

=set-from-line= manages identities: always answer with the =to:= email address when it's to one of my private email addresses. Manage mailing list identities separately (I know of no automatic way, unfortunately.)

#+begin_src emacs-lisp
  (defun aleks/set-from-line ()
    "Set From: address based on To: address of original email.  Also set mailing list addresses."
    (when mu4e-compose-parent-message
      (cond
       ((mu4e-message-contact-field-matches mu4e-compose-parent-message :to "aleks.bg")
        (setq user-mail-address (cdr (car (mu4e-message-field mu4e-compose-parent-message :to)))))
       ((mu4e-message-contact-field-matches mu4e-compose-parent-message :list-post "emacs-orgmode")
        (setq user-mail-address "org@list.aleks.bg")))))

  (use-package mu4e
    :load-path "~/.local/share/emacs/site-lisp/mu4e/"
    :commands mu4e
    :straight (:tag "v1.8.4")
    :config
    (aleks/load-org-file "private.org")
    (evil-set-initial-state 'mu4e-headers-mode 'normal)
    (add-to-list 'mu4e-headers-actions '("in browser" . mu4e-action-view-in-browser) t)
    (add-to-list 'mu4e-view-actions '("in browser" . mu4e-action-view-in-browser) t)
    :hook
    (mu4e-view-mode . aleks/disable-show-trailing-whitespace)
    (mu4e-headers-mode . aleks/disable-show-trailing-whitespace)
    (mu4e-compose-mode . aleks/set-from-line)
    :custom
    (require 'org-mu4e)
    (shr-color-visible-luminance-min 80)
    (mail-user-agent 'mu4e-user-agent)
    (mu4e-update-interval 60)
    (message-send-mail-function 'smtpmail-send-it)
    (mu4e-use-fancy-chars t)
    (mu4e-attachment-dir "~/Downloads")
    (mu4e-view-show-images t)
    (mu4e-headers-fields '((:human-date . 25)
                           (:flags . 6)
                           (:from . 22)
                           (:thread-subject . nil))))
#+END_SRC

** Multi-cursor

Select something visually, hit =R=, and use =n=, =N=, =<return>=  and =<space>= to select other such regions, then edit them all together seamlessly.

#+BEGIN_SRC emacs-lisp
  (use-package evil-multiedit
    :config
    (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)
    :general
    (:states 'visual
             "R" 'evil-multiedit-match-all
             "r" 'evil-multiedit-match-and-next)
    (:states 'normal :prefix ", r"
             "r" 'evil-multiedit-match-and-next
             "R" 'evil-multiedit-match-all)
    (:states 'multiedit
             "RET" 'evil-multiedit-toggle-or-restrict-region
             "n" 'evil-multiedit-next
             "N" 'evil-multiedit-prev
             "M-r" 'evil-multiedit-match-all
             "SPC" 'evil-multiedit-match-and-next
             "S-SPC" 'evil-multiedit-match-and-prev))
#+END_SRC

** Org -Journal

An alternative might be to use =org-roam-dailies= but I saw no benefits so far.

#+begin_src emacs-lisp
  (use-package org-journal)
#+end_src

** Org-Ref

I'm using org-cite nowadays, but org-ref still has important goodies.

#+begin_src emacs-lisp
  (use-package org-ref
    :custom
    (reftex-default-bibliography '("~/doc/lib/bib/main.bib"))
    (org-ref-default-bibliography '("~/doc/lib/bib/main.bib"))
    (org-ref-pdf-directory '("~/doc/lib")))
#+end_src

** Org-Roam

Mostly for lecture notes, ideas for talks, but also random thoughts.

#+begin_src emacs-lisp
  (use-package org-roam
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (file-truename (concat (file-name-as-directory (getenv "HOME")) "org/roam")))
    :config
    (org-roam-setup))
#+end_src

*** UI

Not very useful, except as a motivation to have the network grow.

#+begin_src emacs-lisp
  (use-package org-roam-ui
    :straight
      (:host github :repo "org-roam/org-roam-ui" :branch "main" :files ("*.el" "out"))
      :after org-roam
      :config
      (setq org-roam-ui-sync-theme t
            org-roam-ui-follow t
            org-roam-ui-update-on-save t
            org-roam-ui-open-on-start t))
#+end_src

** Pair Programmer Mode

A mode that eases working with people on code together. It turns on line numbers and also adds a =Co-Authored-By= stanza to every git commit while it is active.

#+begin_src emacs-lisp
  (defvar pair-programming-mode--pair-programmer nil
    "The current pair programmer as (name email)")

  (defun enable-pair-programming-mode ()
    "Set visuals for pair programming mode and prompt for your buddy."
    (global-display-line-numbers-mode 1)
    (let ((pair-programmer (git-commit-read-ident nil)))
      (setq pair-programming-mode--pair-programmer pair-programmer)
      (message (concat "Pair programming with " (car pair-programmer)))))

  (defun disable-pair-programming-mode ()
    "Disable pair programming visuals and settings."
    (setq pair-programming-mode--pair-programmer nil)
    (global-display-line-numbers-mode -1)
    (message "PP mode disabled"))

  (define-minor-mode pair-programming-mode
    "Toggle Pair Programming Mode.
  This prompts for a pair programmer from your current git commit history.
  When you commit with (ma)git, the pair programmer is inserted as a co-author.
  Additionally, line number mode is enabled."
    :group 'pair-programming
    :global t
    :lighter " PP"
    (if pair-programming-mode
        (enable-pair-programming-mode)
      (disable-pair-programming-mode)))

  (defun insert-pair-programmer-as-coauthor ()
    "Insert your pair programer into the current git commit."
    (when (and pair-programming-mode git-commit-mode)
      (pcase pair-programming-mode--pair-programmer
        (`(,name ,email) (git-commit-insert-header "Co-authored-by" name email))
        (_ (error "No pair programmer found or malformed content.")))))

  (add-hook 'git-commit-setup-hook 'insert-pair-programmer-as-coauthor)
#+end_src

** Parentheses

Highlight parentheses in different colours according to their nesting level.

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
      :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

Smartparens to make handling parentheses easier.

#+begin_src emacs-lisp
  (use-package smartparens
    :init
    (require 'smartparens-config)
    :config
    (smartparens-global-mode 1)
    (show-smartparens-global-mode 1)
    :custom
    (smartparens-strict-mode 1)
    (sp-show-pair-delay 0)
    :general
    (:states
     '(insert normal)
     "M-s" 'sp-split-sexp
     "M-l" 'sp-join-sexp ; link
     "C-/" 'sp-forward-barf-sexp
     "C-=" 'sp-forward-slurp-sexp))
#+end_src

** Projectile

I haven't configured =projectile= to use =selectrum=, but it's working alright for now.

#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :config
    (projectile-mode +1)
    :general
    (aleks/global-leader
      :states 'normal
      "p p" 'projectile-switch-project
      "p f" 'projectile-find-file
      "p b" 'projectile-switch-buffer))
  
#+END_SRC

** Ripgrep

Near-instant full-text-search across projects.

#+BEGIN_SRC emacs-lisp
  (use-package rg
    :general
    (aleks/global-leader 'normal
     "s s" 'rg-dwim
     "s p" 'rg-project
     "s l" 'rg-list-searches))
#+END_SRC

** Selection
Try out =selectrum= as an alternative to =ivy=.

#+begin_src emacs-lisp
  (use-package selectrum
    :config
    (selectrum-mode +1))
#+end_src

Use =prescient= for sorting options by /frecency/:

#+begin_src emacs-lisp
  (use-package prescient)
  
  (use-package selectrum-prescient
    :config
    (selectrum-prescient-mode +1)
    (prescient-persist-mode +1))
#+end_src

Add documentation to each selection entry if possible.

#+begin_src emacs-lisp
  (use-package marginalia
    :init
    (marginalia-mode))
#+end_src

** Smerge

Awesome shortcuts to do complicated 3-way-merges with =git=.

#+begin_src emacs-lisp
  (general-define-key
   :states 'normal
   :modes 'smerge-mode
   :prefix ", d"
   "n" 'smerge-next
   "p" 'smerge-prev
   "j" 'smerge-keep-lower
   "k" 'smerge-keep-upper
   "c" 'smerge-keep-all
   "X" 'smerge-keep-base
   "x" 'smerge-swap
   "r" 'smerge-resolve)
#+end_src

** Snippets

Snippets live in version control under the Emacs directory.

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1)
    :custom
    (yas-snippet-dirs '("~/config/emacs/snippets")))
#+end_src

** String Inflection

Useful to cycle between =CamelCase=, =snake_case=, etc. No keybindings, I just call it with =M-x=.

#+begin_src emacs-lisp
  (use-package string-inflection)
#+end_src

** Treesitter

Tree-sitter provides editor-agnostic syntax highlighting. For now it's just used for [[Typescript]] here.

#+begin_src emacs-lisp
  (use-package tree-sitter)
  (use-package tree-sitter-langs
    :after tree-sitter
    :config
    (tree-sitter-require 'tsx))
#+end_src

** Which-Key

=which-key= shows hints after pressing a prefix key. Greatly aids discoverability.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+END_SRC


** Whitespace

Switch on highlighting of trailing white space, and provide a facility to turn it off on a per-mode base, as for some modes it's not useful.

#+begin_src emacs-lisp
  (custom-set-variables '(show-trailing-whitespace t))

  (defun aleks/disable-show-trailing-whitespace ()
      "Disable trailing whitespace."
      (setq show-trailing-whitespace nil))

  (add-hook 'calendar-mode-hook 'aleks/disable-show-trailing-whitespace)
#+end_src


** XJira

An integration for Jira I wrote. The only thing it does is offer a way to capture Jira issues in org-capture templates.

#+begin_src emacs-lisp
  (use-package xjira
    :straight (xjira :type git :host github :repo "adimit/xjira"))
#+end_src

The authorisation and host variables are set in =private.org=.
