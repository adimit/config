* Package Setup
** Melpa
Add Melpa source
#+BEGIN_SRC emacs-lisp
  (require 'package)
  (package-initialize)
  (mapcar (lambda (archive) (add-to-list 'package-archives archive t))
          '(("melpa" . "https://melpa.org/packages/")
            ("org" . "https://orgmode.org/elpa/")
            ("tree-sitter" . "https://elpa.ubolonton.org/packages/")))
#+END_SRC

** Use-Package

Ideally, use of =require= should be completely unnecessary due to =use-package=. It also handles package installs via =ensure=.

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  (eval-when-compile
    (require 'use-package))

  (customize-set-variable
   'use-package-always-ensure t "Always install packages if they're not installed")
#+END_SRC

* Basic Setup
** Auth

This uses =pass= for all auth storage, including =mu4e= and =ghub=. If there are problems remember =(setq auth-source-debug t).=

#+begin_src emacs-lisp
  (auth-source-pass-enable)
#+end_src

Let Emacs query the pass phrase instead of an external pinentry dialogue.

#+begin_src emacs-lisp
  (customize-set-variable 'epg-pinentry-mode 'loopback)
#+end_src

** Backups

No files with =~= everywhere. Prevent creation of lockfiles, as that confuses some watch tasks (notably webpack dev server.)

#+BEGIN_SRC emacs-lisp
  (custom-set-variables
   '(backup-directory-alist `(("." . "~/.saves")))
   '(create-lockfiles nil))
#+END_SRC

** Bindings

#+BEGIN_SRC emacs-lisp
  (use-package general
    :after (evil counsel)
    :config
    (general-define-key
     :states 'normal
     "M-x" 'counsel-M-x
     "RET" 'save-buffer)
    (general-define-key
     :states 'normal
     :prefix ","
     "," (general-simulate-key "M-x")
     "f f" 'counsel-find-file
     "g s" 'magit-status
     "g f" 'magit-file-dispatch
     "g b" 'magit-blame

     "a" 'org-agenda

     "b b" 'counsel-switch-buffer
     "b d" 'kill-current-buffer

     "p p" 'projectile-switch-project
     "p f" 'projectile-find-file
     "p b" 'projectile-switch-to-buffer

     "w n" 'make-frame-command
     "w c" 'evil-window-delete
     "w o" 'other-window
     "w s" 'evil-window-split
     "w v" 'evil-window-vsplit))
#+END_SRC

** Calendar
Calendar is set up for European style display (Monday starts week) and manual location of Tübingen, Germany (for sunrise/sunset).
Tübingen Hbf is: =48.516738, 9.055493=

#+BEGIN_SRC emacs-lisp
  (defvar holiday-baden-württemberg-holidays
    '((holiday-fixed 1 1 "Neujahr")
      (holiday-fixed 1 6 "Heilige Drei Könige")
      (holiday-fixed 5 1 "Tag der Arbeit")
      (holiday-fixed 10 3 "Tag der deutschen Einheit")
      (holiday-fixed 11 1 "Allerheiligen")
      (holiday-fixed 12 25 "Erster Weihnachtsfeiertag")
      (holiday-fixed 12 26 "Zweiter Weihnachtsfeiertag")
      (holiday-easter-etc -2 "Karfreitag")
      (holiday-easter-etc +1 "Ostermontag")
      (holiday-easter-etc +39 "Christi Himmelfahrt")
      (holiday-easter-etc +50 "Pfingstmontag")
      (holiday-easter-etc +60 "Fronleichnam")))

  (use-package calendar
    :defer t
    :custom
    (calendar-week-start-day 1)
    (calendar-latitude 48.516738)
    (calendar-longitude 9.055493)
    (calendar-location-name "Tübingen, Germany")
    (calendar-holidays (append holiday-solar-holidays
                               holiday-baden-württemberg-holidays))
    (calendar-date-style 'european)
    (calendar-time-display-form
     '(24-hours ":" minutes (if time-zone (concat " (" time-zone ")")))))

#+END_SRC

Here's a function that returns whether it's currently dark outside, so you don't have to look.

#+begin_src emacs-lisp
  (defun aleks/is-it-dark-p ()
    "Return t if it's dark outside, otherwise nil.

  Will look at the `current-time' and calculate sunset and sunrise times
  according to `calendar-longitude' and `calendar-latitude' using
  `solar-sunrise-sunset'so make sure you've set your location."
    (require 'solar)
    (let* ((solar (solar-sunrise-sunset (calendar-current-date)))
	 (sunrise (car (car solar)))
	 (sunset (car (car (cdr solar))))
	 (time (decode-time (current-time)))
	 (hour (nth 2 time))
	 (minute (nth 1 time))
	 (minute-fraction (/ minute 60.0))
	 (time-decimal (+ hour minute-fraction)))
    (or (> time-decimal sunset) (< time-decimal sunrise))))
#+end_src

** Customisations

Don't store customisations, they usually surprise me by being there and making things not work as expected.

#+begin_src emacs-lisp
  (customize-set-variable 'custom-file null-device)
#+end_src

** Evil
*** Basic settings
Activate evil mode
#+BEGIN_SRC emacs-lisp
  (use-package evil
    :config
    (evil-mode t))

  (use-package evil-surround
    :config
    (global-evil-surround-mode t))

  (use-package evil-exchange
    :config (evil-exchange-install))

  (use-package evil-goggles
    :after evil
    :config (evil-goggles-mode))
#+END_SRC

*** Multi-cursor
#+BEGIN_SRC emacs-lisp
  (use-package evil-multiedit
    :config
    (evil-ex-define-cmd "ie[dit]" 'evil-multiedit-ex-match)
    :general
    (:states 'visual
             "R" 'evil-multiedit-match-all
             "r" 'evil-multiedit-match-and-next)
    (:states 'normal :prefix ", r"
             "r" 'evil-multiedit-match-and-next
             "R" 'evil-multiedit-match-all)
    (:states 'multiedit
             "RET" 'evil-multiedit-toggle-or-restrict-region
             "n" 'evil-multiedit-next
             "N" 'evil-multiedit-prev
             "M-r" 'evil-multiedit-match-all
             "SPC" 'evil-multiedit-match-and-next
             "S-SPC" 'evil-multiedit-match-and-prev))
#+END_SRC


** Region and IEdit

=evil-iedit-state= builds off of =expand-region= to provide the functionality to edit multiple occurrences of the current region.

#+begin_src emacs-lisp
  (use-package expand-region
    :general (:states 'normal :prefix ","
                      "SPC" 'er/expand-region))
  (use-package evil-iedit-state
    :after expand-region)
#+end_src

** Server
Enable emacs server mode.

#+begin_src emacs-lisp
  (server-mode)
#+end_src

There are two shell aliases that help with server mode:

#+begin_src shell
  alias ec=emacsclient -n
  alias ecc=emacsclient -cn
#+end_src

=ecc= opens another frame, and =ec= just re-uses an existing frame.

* Visual Configuration
** Faces & Theme

Instead of using a package like =org-variable-pitch-mode=, the following definition takes care of setting up which parts of =org-mode= are fixed pitch.

#+begin_src emacs-lisp
  (defun aleks/set-org-mode-fixed-pitch-faces ()
    (mapc (lambda (face) (set-face-attribute face nil :inherit 'fixed-pitch))
          `(org-block
            org-special-keyword
            org-drawer
            org-todo
            org-done
            org-priority
            org-checkbox
            org-block-end-line
            org-block-begin-line
            org-table org-verbatim)))

#+end_src

Since sans serif fonts seem to be more easily readable when the background is black, and serif fonts just look so good on white background, we set up different font sets for light and dark mode.

#+begin_src emacs-lisp
  (defun aleks/set-light-mode-faces ()
    "Set the faces for light mode."
    (custom-set-faces
     '(variable-pitch ((t (:family "Bitter" :height 160 ))))
     '(fixed-pitch ((t (:family "Fira Code" :height 150))))
     '(default ((t (:family "Fira Code" :height 150))))))

  (defun aleks/set-dark-mode-faces ()
    "Set the faces for dark mode."
    (custom-set-faces
     '(variable-pitch ((t (:family "Bitter" :height 160))))
     '(fixed-pitch ((t (:family "Fira Code" :height 150))))
     '(default ((t (:family "Fira Code" :height 150))))))
#+end_src

I'm using Prot's modus themes for light and dark mode. They're only loaded here, not enabled.

#+begin_src emacs-lisp
  (use-package modus-vivendi-theme
    :custom
    (modus-vivendi-theme-scale-headings t)
    (modus-vivendi-theme-slanted-constructs t)
    (modus-vivendi-theme-scale-1 1.1)
    (modus-vivendi-theme-scale-2 1.2)
    (modus-vivendi-theme-scale-3 1.3)
    (modus-vivendi-theme-scale-4 1.4)
    (modus-vivendi-theme-scale-5 1.5)
    :config
    (load-theme 'modus-vivendi t t))

  (use-package modus-operandi-theme
    :custom
    (modus-operandi-theme-scale-headings t)
    (modus-operandi-theme-slanted-constructs t)
    (modus-operandi-theme-scale-1 1.1)
    (modus-operandi-theme-scale-2 1.2)
    (modus-operandi-theme-scale-3 1.3)
    (modus-operandi-theme-scale-4 1.4)
    (modus-operandi-theme-scale-5 1.5)
    :config
    (load-theme 'modus-operandi t t))
#+end_src

Finally, let's define dark and light mode…

#+begin_src emacs-lisp
  (defun aleks/dark-mode ()
    "Set theme and fonts for dark mode."
    (interactive)
    (enable-theme 'modus-vivendi)
    (aleks/set-org-mode-fixed-pitch-faces)
    (aleks/set-dark-mode-faces))

  (defun aleks/light-mode ()
    "Set theme and fonts for dark mode."
    (interactive)
    (enable-theme 'modus-operandi)
    (aleks/set-org-mode-fixed-pitch-faces)
    (aleks/set-light-mode-faces))
#+end_src

And here's a function that can choose the correct theme according to the current sunset/sunrise time. I don't like automatic switching, as switching themes introduces lag and is rather disruptive.

#+begin_src emacs-lisp
  (defun aleks/auto-choose-theme ()
    "Choose between dark and light based on sunrise/sunset time."
    (interactive)
    (if (aleks/is-it-dark-p)
        (aleks/dark-mode)
      (aleks/light-mode)))
#+end_src

When starting up, choose a theme based on the current time.

#+begin_src emacs-lisp
  (with-eval-after-load 'calendar
    (aleks/auto-choose-theme))
#+end_src

** Miscellaneous Improvements

#+BEGIN_SRC emacs-lisp
  (blink-cursor-mode 0)
  (global-hl-line-mode)
  (set-face-attribute hl-line-face nil :underline nil)
  (menu-bar-mode -1)
  (scroll-bar-mode -1)
  (tool-bar-mode -1)
  (fset 'yes-or-no-p 'y-or-n-p)
  (custom-set-variables
   '(inhibit-startup-screen t)
   '(indent-tabs-mode nil)
   '(initial-scratch-message "")
   '(mouse-yank-at-point t)
   '(show-trailing-whitespace t))
#+END_SRC

** Mode line

#+BEGIN_SRC emacs-lisp
  (use-package doom-modeline
    :custom
    (doom-modeline-icon t)
    (doom-modeline-buffer-file-name-style 'buffer-name)
    (doom-modeline-buffer-state-icon nil)
    (doom-modeline-mu4e t)
    (doom-modeline-buffer-encoding nil)
    :hook
    (after-init . doom-modeline-mode))
#+END_SRC

** Text mode buffers

Text mode buffers have spell check enabled, are narrowed, and use variable pitch and word wrap.

#+begin_src emacs-lisp
  (defun aleks/text-mode-hook ()
    (flyspell-mode)
    (visual-line-mode)
    (variable-pitch-mode)
    (olivetti-mode))

  (add-hook 'text-mode-hook 'aleks/text-mode-hook)
#+end_src

* Extensions
** Beacon
#+BEGIN_SRC emacs-lisp
  (use-package beacon
    :config
    (beacon-mode 1)
    :custom
    (beacon-blink-delay 0.15)
    (beacon-blink-duration 0.15))
#+END_SRC

** Company

#+BEGIN_SRC emacs-lisp
  (use-package company
    :custom
    (company-dabbrev-downcase nil)
    (company-dabbrev-ignore-case nil)
    (company-idle-delay 0)
    :config
    (global-company-mode)
    :general
    (:keymaps 'company-active-map
              "C-n" 'company-select-next
              "C-p" 'company-select-previous
              "C-f" 'company-filter-candidates))
#+END_SRC

Posframe mode allows completions to not look silly in =variable-pitch-mode=.

#+begin_src emacs-lisp
  (use-package company-posframe
    :config (company-posframe-mode 1))
#+end_src

** Diff-hl
#+BEGIN_SRC emacs-lisp
  (use-package diff-hl
    :hook
    (magit-post-refresh . diff-hl-magit-post-refresh)
    :config
    (global-diff-hl-mode)
    :custom
    (diff-hl-side 'right))
#+END_SRC

** Dired

Show dired as sidebar and add keybindings for toggle & full dired.

#+begin_src emacs-lisp
  (customize-set-variable 'dired-dwim-target t)
  (add-hook 'dired-mode-hook 'dired-hide-details-mode)

  (use-package dired-toggle
    :general
    (:states 'normal :prefix ", d"
             "d" (lambda () (interactive) (dired "."))
             "h" 'dired-toggle)
    (:keymaps 'dired-mode-map
   "q" 'evil-window-delete)
    :bind
    ([remap dired-find-file] . #'dired-toggle-find-file)
    ([remap dired-up-directory] . #'dired-toggle-up-directory)
    :custom
    (dired-toggle-window-size 32)
    (dired-toggle-window-side 'left)
    :hook
    (dired-toggle-mode . (lambda () (interactive)
                           (visual-line-mode 1)
                           (setq-local visual-line-fringe-indicators '(nil right-curly-arrow))
                           (setq-local word-wrap nil))))
#+end_src

** Editorconfig
#+BEGIN_SRC emacs-lisp
  (use-package editorconfig
    :config (editorconfig-mode 1))
#+END_SRC

** Elfeed

Here's the list of subscribed feeds.

#+begin_src emacs-lisp
  (defcustom aleks/subscribed-feeds
    (list "https://www.smbc-comics.com/comic/rss"
          "https://xkcd.com/rss.xml"
          "https://fedoramagazine.org/feed/"
          "https://augengeradeaus.net/feed/"
          "https://updates.orgmode.org/feed/help"
          "https://updates.orgmode.org/feed/bugs")
    "List of feeds to subscribe to")
#+end_src

Elfeeds keybindings are completely broken with evil, so we need to redefine them all.

#+begin_src emacs-lisp
  (use-package elfeed
    :hook
    (elfeed-show-mode . olivetti-mode)
    :commands (elfeed)
    :custom
    (elfeed-feeds aleks/subscribed-feeds)
    :general
    (:keymaps 'elfeed-search-mode-map
              :states 'normal
              "RET" 'elfeed-search-show-entry
              "+" 'elfeed-search-tag-all
              "-" 'elfeed-search-untag-all
              "<" 'elfeed-search-first-entry
              ">" 'elfeed-search-last-entry
              ">" 'elfeed-search-last-entry
              "f" 'elfeed-search-fetch
              "S" 'elfeed-search-set-filter
              "b" 'elfeed-search-browse-url
              "c" 'elfeed-search-clear-filter
              "F" 'elfeed-search-update--force
              "q" 'elfeed-search-quit-window
              "r" 'elfeed-search-untag-all-unread
              "s" 'elfeed-search-live-filter
              "u" 'elfeed-search-tag-all-unread
              "y" 'elfeed-search-yank
              "U" 'elfeed-update)
    (:keymaps 'elfeed-show-mode-map
              :states 'normal
              "TAB"  'elfeed-show-next-link
              "SPC"  'scroll-up-command
              "+"    'elfeed-show-tag
              "-"    'elfeed-show-untag
              "0"    'digit-argument
              "<"    'beginning-of-buffer
              ">"    'end-of-buffer
              "A"    'elfeed-show-add-enclosure-to-playlist
              "P"    'elfeed-show-play-enclosure
              "b"    'elfeed-show-visit
              "c"    'elfeed-kill-link-url-at-point
              "d"    'elfeed-show-save-enclosure
              "F"    'elfeed-show-refresh
              "h"    'describe-mode
              "n"    'elfeed-show-next
              "p"    'elfeed-show-prev
              "q"    'elfeed-kill-buffer
              "s"    'elfeed-show-new-live-search
              "u"    'elfeed-show-tag--unread
              "y"    'elfeed-show-yank))
#+end_src

** Flycheck
#+BEGIN_SRC emacs-lisp
  (use-package flycheck
    :config (global-flycheck-mode))
#+END_SRC

*** Checkdoc in org src edit buffers
=checkdoc= will insist on headers, footers, commentary sections etc. in all your elisp code, including code that's opened with =org-src-edit=, which makes no sense at all. The corresponding function is =checkdoc-comments= and it runs whenever =buffer-file-name= is set. Org src edit buffers do set a file name, so =checkdoc= happily checks their comments. There's no way to exclude just one kind of check, so we just disable checkdoc in =org-src-edit= buffers.

#+begin_src emacs-lisp
  (defun disable-checkdoc ()
    (setq-local flycheck-disabled-checkers '(emacs-lisp-checkdoc)))
  (add-hook 'org-src-mode-hook 'disable-checkdoc)
#+end_src

** Indent Guides

#+begin_src emacs-lisp
  (use-package highlight-indent-guides
    :hook (prog-mode . highlight-indent-guides-mode)
    :custom (highlight-indent-guides-method 'character))
#+end_src

** Ivy & Counsel

Perhaps try [[https://github.com/raxod502/selectrum][selectrum]] one of these days?

#+BEGIN_SRC emacs-lisp
  (use-package ivy
    :config
    (ivy-mode 1)
    :custom
    (ivy-use-virtual-buffers t))
  (use-package counsel)
#+END_SRC

*** Prescient
#+BEGIN_SRC emacs-lisp
  (use-package prescient
    :config (prescient-persist-mode 1))
  (use-package ivy-prescient
    :config (ivy-prescient-mode 1))
  (use-package company-prescient
    :config (company-prescient-mode 1))
#+END_SRC

** LSP
#+BEGIN_SRC emacs-lisp
  (use-package lsp-mode
    :commands lsp lsp-deferred
    :custom (read-process-output-max (* 1024 1024))
    :general
    (:states 'normal
     ", l x" 'lsp-execute-code-action
     "M-RET" 'lsp-execute-code-action))

  (use-package lsp-ui
    :commands lsp-ui-mode
    :custom
    (lsp-ui-doc-header t)
    (lsp-ui-doc-position 'at-point)
    (lsp-ui-doc-delay 1)
    (lsp-ui-doc-use-childframe 't)
    :general
    (:states 'normal
     :prefix ", l"
     "h" 'lsp-ui-doc-hide
     "d" 'lsp-describe-thing-at-point
     "u" 'lsp-ui-doc-unfocus-frame
     "f" 'lsp-ui-doc-focus-frame
     "l" 'flycheck-list-errors
     "n" 'flycheck-next-error
     "p" 'flycheck-previous-error))

  (use-package company-lsp
    :commands company-lsp
    :after lsp lsp-mode)
#+END_SRC

** Magit
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :commands magit magit-status)
  (use-package evil-magit
    :after magit)
  (use-package forge
    :after magit)
#+END_SRC

*** Add Issue Number to Commit Message
Insert the current ticket number if we're on a =KNUTH= feature branch.

#+begin_src emacs-lisp
  (defun buffer-insert-at-end (string)
    "Insert STRING at the maximal point in a buffer."
    (save-excursion
      (goto-char (point-max))
      (end-of-line)
      (insert ?\n string)
      (unless (string-suffix-p "\n" string)
        (insert ?\n))))

  (defun get-knuth-number-from-string (string)
    "Return KNUTH issue number from STRING.
  Return nil if STRING does not contain a KNUTH issue.
  STRING may be nil."
    (if (and string (string-match "\\(KNUTH-[[:digit:]]\+\\)" string))
        (match-string 1 string)
      nil))

  (defun insert-knuth-ticket-number-from-branch ()
    "If we're on a KNUTH feature branch, insert the ticket number."
    (interactive)
    (let ((knuth (get-knuth-number-from-string (magit-get-current-branch))))
      (if (and knuth (not (buffer-line-matches-p (concat "^" knuth)))) (buffer-insert-at-end knuth))))

  (defun buffer-line-matches-p (needle)
    "Return t if the last line matches NEEDLE.
  Ignores comments"
    (save-excursion
      (goto-char 0)
      (search-forward-regexp needle nil 'noerror)))

  (add-hook 'git-commit-setup-hook 'insert-knuth-ticket-number-from-branch)
#+end_src

** Mu4e

The context definitions are in =private.org=.

=set-from-line= manages identities: always answer with the =to:= email address when it's to one of my private email addresses. Manage mailing list identities separately (I know of no automatic way, unfortunately.)

#+begin_src emacs-lisp
  (defun aleks/set-from-line ()
    "Set From: address based on To: address of original email.  Also set mailing list addresses."
    (when mu4e-compose-parent-message
      (cond
       ((mu4e-message-contact-field-matches mu4e-compose-parent-message :to "aleks.bg")
        (setq user-mail-address (cdr (car (mu4e-message-field mu4e-compose-parent-message :to)))))
       ((mu4e-message-contact-field-matches mu4e-compose-parent-message :list-post "emacs-orgmode")
        (setq user-mail-address "org@list.aleks.bg")))))

  (defun aleks/disable-show-trailing-whitespace ()
    "Disable trailing whitespace."
    (setq show-trailing-whitespace nil))

  (use-package mu4e
    :load-path "~/.local/share/emacs/site-lisp/mu4e/"
    :commands mu4e
    :config
    (evil-set-initial-state 'mu4e-headers-mode 'normal)
    (add-to-list 'mu4e-headers-actions '("in browser" . mu4e-action-view-in-browser) t)
    (add-to-list 'mu4e-view-actions '("in browser" . mu4e-action-view-in-browser) t)
    :hook
    (mu4e-view-mode . aleks/disable-show-trailing-whitespace)
    (mu4e-headers-mode . aleks/disable-show-trailing-whitespace)
    (mu4e-compose-mode . aleks/set-from-line)
    :custom
    (require 'org-mu4e)
    (shr-color-visible-luminance-min 80)
    (mail-user-agent 'mu4e-user-agent)
    (mu4e-update-interval 60)
    (message-send-mail-function 'smtpmail-send-it)
    (mu4e-use-fancy-chars t)
    (mu4e-attachment-dir "~/Downloads")
    (mu4e-view-show-images t)
    (mu4e-headers-fields '((:human-date . 25)
                           (:flags . 6)
                           (:from . 22)
                           (:thread-subject . nil))))
#+END_SRC

*** Keybindings

For some reason, the =:general= keyword on =use-package= kept =mu4e= from being properly initialised, hence the separate declaration here.

#+begin_src emacs-lisp
  (general-define-key
   :keymaps 'mu4e-headers-mode-map
   :states 'normal
   "RET" 'mu4e-headers-view-message
   "!" 'mu4e-headers-mark-for-read
   "#" 'mu4e-mark-resolve-deferred-marks
   "$" 'mu4e-show-log
   "%" 'mu4e-headers-mark-pattern
   "&" 'mu4e-headers-mark-custom
   "*" 'mu4e-headers-mark-for-something
   "+" 'mu4e-headers-mark-for-flag
   "-" 'mu4e-headers-mark-for-unflag
   "/" 'mu4e-headers-search-narrow
   "n" 'mu4e-headers-rerun-search
   ";" 'mu4e-context-switch
   "?" 'mu4e-headers-mark-for-unread
   "A" 'mu4e-headers-mark-for-action
   "B" 'mu4e-headers-search-bookmark-edit
   "C" 'mu4e-compose-new
   "D" 'mu4e-headers-mark-for-delete
   "E" 'mu4e-compose-edit
   "F" 'mu4e-compose-forward
   "H" 'mu4e-display-manual
   "O" 'mu4e-headers-change-sorting
   "P" 'mu4e-headers-toggle-threading
   "Q" 'mu4e-headers-toggle-full-search
   "R" 'mu4e-compose-reply
   "S" 'mu4e-headers-search-edit
   "T" 'mu4e-headers-mark-thread
   "U" 'mu4e-mark-unmark-all
   "V" 'mu4e-headers-toggle-skip-duplicates
   "W" 'mu4e-headers-toggle-include-related
   "[" 'mu4e-headers-prev-unread
   "\\" 'mu4e-headers-query-prev
   "]" 'mu4e-headers-next-unread
   "a" 'mu4e-headers-action
   "b" 'mu4e-headers-search-bookmark
   "d" 'mu4e-headers-mark-or-move-to-trash
   "m" 'mu4e-headers-mark-for-move
   "q" 'mu4e~headers-quit-buffer
   "r" 'mu4e-headers-mark-for-refile
   "s" 'mu4e-headers-search
   "t" 'mu4e-headers-mark-subthread
   "u" 'mu4e-headers-mark-for-unmark
   "x" 'mu4e-mark-execute-all
   "y" 'mu4e-select-other-view
   "J" 'mu4e~headers-jump-to-maildir
   "k" 'mu4e-headers-prev
   "j" 'mu4e-headers-next)
#+end_src

** Olivetti

#+begin_src emacs-lisp
  (use-package olivetti
    :commands (olivetti-mode))
#+end_src

** Projectile
#+BEGIN_SRC emacs-lisp
  (use-package projectile
    :commands projectile-find-file projectile-switch-project projectile-switch-buffer
    :config
    (projectile-mode +1)
    :custom
    (projectile-completion-system 'ivy))
#+END_SRC

** Parentheses
#+BEGIN_SRC emacs-lisp
  (use-package smartparens
    :hook
    (prog-mode . smartparens-mode)
    (prog-mode . show-paren-mode) ; not smartparens, but eh
    :custom
    (show-paren-delay 0)
    :config
    (require 'smartparens-config)
    :general
    (:states 'normal :prefix "["
                      "s" 'sp-forward-slurp-sexp
                      "S" 'sp-backward-slurp-sexp
                      "b" 'sp-forward-barf-sexp
                      "B" 'sp-backward-barf-sexp)
    (:states 'normal :prefix "["
             "[" 'sp-beginning-of-sexp
             "{" 'sp-up-sexp)
    (:states 'normal :prefix "]"
             "]" 'sp-end-of-sexp
             "}" 'sp-down-sexp))

  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

** Ripgrep
#+BEGIN_SRC emacs-lisp
  (use-package rg
    :general
    (:states 'normal
     :prefix ", s"
     "s" 'rg-dwim
     "p" 'rg-project
     "l" 'rg-list-searches
     "S" 'rg-save-search))
#+END_SRC

** Roam
#+BEGIN_SRC emacs-lisp
  (use-package org-roam
    :custom
    (org-roam-directory (concat (file-name-as-directory (getenv "HOME")) "org/roam"))
    (org-roam-completion-system 'ivy)
    :general
    (:states 'normal
             ", f r" 'org-roam-find-file)
    (:states 'normal :definer 'minor-mode :keymaps 'org-roam-mode :prefix ", ."
             "i" 'org-roam-insert
             "I" 'org-roam-insert-immediate
             "b" 'org-roam-buffer-toggle-display))

  (use-package company-org-roam
    :after (org-roam)
    :config (push 'company-org-roam company-backends))
#+END_SRC

** Smerge
#+begin_src emacs-lisp
  (general-define-key
   :states 'normal
   :modes 'smerge-mode
   :prefix ", d"
   "n" 'smerge-next
   "p" 'smerge-prev
   "j" 'smerge-keep-lower
   "k" 'smerge-keep-upper
   "c" 'smerge-keep-all
   "X" 'smerge-keep-base
   "x" 'smerge-swap
   "r" 'smerge-resolve)
#+end_src

** Treemacs
#+BEGIN_SRC emacs-lisp
  (use-package treemacs
    :commands treemacs
    :general
    (:states 'normal
             :prefix ", t"
             "t" 'treemacs
             "f" 'treemacs-find-file
             "p" 'treemacs-projectile
             "P" 'treemacs-add-and-display-current-project)
    :config
    (treemacs-follow-mode t)
    (treemacs-git-mode 'deferred)
    (treemacs-filewatch-mode t)
    (evil-define-key 'treemacs treemacs-mode-map (kbd "tn") #'treemacs-create-file)
    (evil-define-key 'treemacs treemacs-mode-map (kbd "td") #'treemacs-create-dir)
    (evil-define-key 'treemacs treemacs-mode-map (kbd "tc") #'treemacs-copy-file))

  (use-package treemacs-evil
    :after treemacs evil)
  (use-package treemacs-projectile
    :after treemacs projectile)
  (use-package treemacs-magit
    :after treemacs magit)
#+END_SRC

** Tree-Sitter

#+begin_src emacs-lisp
  (use-package tree-sitter
    :hook
    (typescript-mode . tree-sitter-mode)
    (typescript-mode . tree-sitter-hl-mode)
    :ensure tree-sitter-langs)
#+end_src

** Which-Key
#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+END_SRC

** Yasnippet

#+begin_src emacs-lisp
  (use-package yasnippet
    :config
    (yas-global-mode 1)
    :custom
    (yas-snippet-dirs '("~/config/newmacs/snippets")))
#+end_src
* File Modes
** CSS
#+BEGIN_SRC emacs-lisp
  (use-package css-mode
    :mode "\\.css$"
    :custom (css-indent-offset 2))
  (use-package scss-mode
    :mode ("\\.scss$" "\\.sass$"))
#+END_SRC

** CSV

#+BEGIN_SRC emacs-lisp
  (use-package csv-mode
    :mode "\\.[ct]sv$")
#+END_SRC

** Dart
#+BEGIN_SRC emacs-lisp
  (use-package dart-mode
    :mode "\\.dart$")

  (use-package lsp-dart
    :hook (dart-mode . lsp-deferred)
    :custom
    (lsp-dart-sdk-dir (concat (file-name-as-directory (getenv "HOME"))
                              "local/dart-sdk")))
#+END_SRC

We also want some Flutter support

#+BEGIN_SRC emacs-lisp
  (use-package flutter
    :after dart-mode
    :custom (flutter-sdk-path (concat (file-name-as-directory (getenv "HOME")) "local/flutter")))
#+END_SRC

** Docker
#+BEGIN_SRC emacs-lisp
  (use-package dockerfile-mode :mode "Dockerfile")
#+END_SRC

** Emacs-Lisp
#+BEGIN_SRC emacs-lisp
  (general-define-key
   :states 'normal
   :keymaps 'emacs-lisp-mode-map
   :prefix ", ."
   "e e" 'eval-last-sexp
   "e b" 'eval-buffer)
#+END_SRC

** Fish
#+BEGIN_SRC emacs-lisp
  (use-package fish-mode
    :mode "\\.fish$")
#+END_SRC

** Graphql
#+BEGIN_SRC emacs-lisp
  (use-package request
    :commands (request))

  (use-package graphql-mode
    :mode "\\.graphql$"
    :custom (graphql-indent-level 4))
#+END_SRC

** Groovy
#+BEGIN_SRC emacs-lisp
  (use-package groovy-mode
    :mode "build\\.gradle" "\\.groovy$")
#+END_SRC

** Haskell
#+BEGIN_SRC emacs-lisp
  (use-package haskell-mode
    :mode "\\.hs$")
#+END_SRC

** JS & friends
*** Json
#+BEGIN_SRC emacs-lisp
  (use-package json-mode
    :mode "\\.json$"
    :config
    (add-to-list 'flycheck-disabled-checkers 'json-python-json))
#+END_SRC

*** JS
#+BEGIN_SRC emacs-lisp
  (setq-default js-indent-level 2)
#+END_SRC

*** Typescript
#+BEGIN_SRC emacs-lisp
  (use-package prettier
    :hook
    (typescript-mode . prettier-mode)
    (json-mode . prettier-mode))

  (use-package typescript-mode
    :mode "\\.tsx?$"
    :hook
    (typescript-mode . lsp)
    :custom
    (typescript-indent-level 2))
#+END_SRC

** Kotlin
Only basic support :(

#+BEGIN_SRC emacs-lisp
  (use-package kotlin-mode
    :mode "\\.kt$")
#+END_SRC

** Ledger
#+BEGIN_SRC emacs-lisp
  (defun browse-paypal-history-at-point ()
    "Open paypal.com order history.  The search term is an exact date range from `thing-at-point'."
    (interactive)
    (let ((date (substring (replace-regexp-in-string
                            (regexp-quote "/") "-"
                            (thing-at-point 'symbol 'no-props)
                            nil 'literal)
                           0 10)))
      (browse-url (concat "https://www.paypal.com/myaccount/transactions/?start_date=" date "&end_date=" date))))

  (defun browse-amazon-history-at-point ()
    "Open amazon.de order history.  The search term is `thing-at-point'."
    (interactive)
    (browse-url (concat "https://www.amazon.de/gp/your-account/order-history/?search=" (thing-at-point 'symbol 'no-props))))

  (use-package ledger-mode
    :mode "hledger\\.journal$" "\\.ledger$"
    :general
    (:states 'normal :keymaps 'ledger-mode-map :prefix ", ."
             "a" 'browse-amazon-history-at-point
             "p" 'browse-paypal-history-at-point))

  (use-package flycheck-ledger
    :after flycheck ledger-mode)
#+END_SRC

** Lua
#+BEGIN_SRC emacs-lisp
  (use-package lua-mode
    :mode "\\.lua$"
    :interpreter "lua")
#+END_SRC

** Markdown
#+BEGIN_SRC emacs-lisp
  (use-package markdown-mode
    :mode "\\.md$"
    :custom (markdown-fontify-code-blocks-natively t))
#+END_SRC

** Org-Mode
*** Installation
Side-load =org-plus-contrib= (for =ox-confluence=) and set up some
mostly visual hooks. Also ensure that code is displayed in fixed pitch
in org mode.

#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure org-plus-contrib
    :mode ("\\.org$" . org-mode)
    :hook
    (org-mode . org-indent-mode)
    (org-mode . variable-pitch-mode)
    (org-agenda-mode . olivetti-mode)
    (org-agenda-mode . variable-pitch-mode)
    :config
    (aleks/set-org-mode-fixed-pitch-faces)
    (org-clock-persistence-insinuate)
    (require 'ox-confluence)
    :custom
    (org-tags-column
     0
     "Aligning tags is broken with variable pitch")
    (org-clock-persist
     t
     "Clocks survive closing Emacs.")
    (org-footnote-section
     nil
     "Place footnotes in the same section they're referenced")
    (org-hide-emphasis-markers t)
    (org-babel-confirm-evaluate nil "I trust my org files")

                                          ; Refiling
    (org-outline-path-complete-in-steps
     nil
     "Use a flat list instead of hierarchichal steps")
    (org-refile-targets
     '((nil . (:maxlevel . 4)))
     "Don't descend more than 4 levels for refiling")
    (org-refile-use-outline-path
     'file
     "Include file names when refiling")

                                          ; Agenda
    (org-agenda-include-diary t)
    (org-agenda-window-setup 'current-window)
    (org-agenda-restore-windows-after-quit t)
    (org-directory
     (concat (file-name-as-directory (getenv "HOME")) "org"))
    (my-org-main-file
     (concat (file-name-as-directory org-directory) "main.org"))
    (my-org-work-file
     (concat (file-name-as-directory org-directory) "work.org"))
    (org-agenda-files
     `(,my-org-main-file ,my-org-work-file))
    (diary-file (concat (file-name-as-directory org-directory) "diary"))
    (org-agenda-custom-commands
     '(("u" "Unscheduled TODO" todo ""
        ((org-agenda-overriding-header "\nUnscheduled TODO")
         (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))))))
    :general
    (:states 'normal :keymaps 'org-mode-map :prefix ", ."
             "'" 'org-edit-special
             "i" 'org-insert-structure-template
             "o" 'org-open-at-point
             "h" 'org-promote-subtree
             "l" 'org-demote-subtree
             "a" 'org-archive-subtree
             "s" 'org-schedule
             "d" 'org-deadline
             "e" 'org-set-effort
             "c c" 'org-clock-in
             "c i" 'org-clock-in
             "c o" 'org-clock-out
             "c g" 'org-clock-goto
             "c x" 'org-clock-cancel
             "r" 'org-refile)
    (:states 'normal :keymaps 'org-mode-map :prefix ","
             "'" 'org-edit-special)
    (:states 'normal :prefix ", c"
             "c" 'org-capture
             "i" 'org-clock-in-last
             "r" 'org-mru-clock-in
             "g" 'org-clock-goto
             "o" 'org-clock-out)
    (:states 'normal :definer 'minor-mode :keymaps 'org-src-mode
             "RET" 'org-edit-src-exit
             "<backspace>" 'org-edit-src-abort)
    (:states 'normal :keymaps 'org-src-minor-mode-map
             "RET" 'org-edit-src-exit
             "BS" 'org-edit-src-abort)
    (:keymaps 'org-agenda-mode-map
              "k" 'org-agenda-previous-item
              "j" 'org-agenda-next-item
              "I" 'org-agenda-diary-entry
              "i" 'org-agenda-clock-in
              "s" 'org-agenda-schedule
              "c" 'org-capture
              "O" 'delete-other-windows
              "o" 'org-agenda-clock-out))

#+END_SRC

*** Prettification

Prettier lists, by substituting bullet points for list item markers.

#+BEGIN_SRC emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "•"))))))
#+END_SRC

This hides heading bullets for a cleaner look.

#+BEGIN_SRC emacs-lisp
  (use-package org-bullets
    :hook
    (org-mode . org-bullets-mode)
    :custom
    (org-bullets-bullet-list '(" "))
    (org-fontify-whole-heading-line t)
    (org-pretty-entities t))
#+END_SRC

*** Capture

#+BEGIN_SRC emacs-lisp
  (setq org-capture-templates
        '(("c" "Todo" entry (file+headline my-org-main-file "NEW")
           "* TODO %^{Title}\nCreated: %U\nRef: %f %a\n%i%?")
          ("C" "Add to current" entry (clock)
           "- [ ] %i%?"
           :prepend t)
          ("u" "Urgent item" entry (file+headline my-org-work-file "NEW")
           "* TODO %^{Title}\n:PROPERTIES:\n:TIMESTAMP: %U\n:Reference: %f %a\n:END:\n%i%?"
           :clock-in t)
          ("w" "Work" entry (file+headline my-org-work-file "NEW")
           "* TODO %^{Title}\nCreated: %U\nRef: %f %a\n%i%?")
          ("s" "Add sprint task" entry (file+headline my-org-work-file "Tasks")
           "* TODO %^{Title}\n:PROPERTIES:\n:TIMESTAMP: %U\n:Reference: %f %a\n:END:\n%i%?")
          ("j" "Add Jira ticket" entry (file+headline my-org-work-file "Tasks")
           "* TODO KNUTH-%^{KNUTH} %?\n:PROPERTIES:\n:TIMESTAMP: %U\n:Reference: http://xjira/browse/KNUTH-%\\1\n:END:\n%i")
          ("S" "Sprint" entry (file my-org-work-file)
           (function (lambda () (string-join
            '("* Sprint %^{Title} [[http://xjira/secure/RapidBoard.jspa?rapidView=292&quickFilter=2360][(board)]]"
              ""
              "** Meetings"
              "*** Daily"
              "*** Refinement"
              "*** Sprint Review"
              "*** Retro"
              "*** SP1"
              "*** SP2"
              "** Overhead"
              "*** Calls"
              "*** Code Review"
              "*** Emails"
              "** Tasks"
              "%i%?")
            "\n")))
           :jump-to-captured t)))
#+END_SRC

Keybindings in capture mode

#+BEGIN_SRC emacs-lisp
  (general-define-key
   :modes 'org-capture-mode
   :states 'normal
   :prefix ", ."
   "c" 'org-capture-finalize
   "r" 'org-capture-refile
   "k" 'org-capture-kill
   "x" 'org-capture-kill)
#+END_SRC

*** Reveal

Support for generating slides from org mode. Removed =ox-reveal= for now as it was messing with structure templates. The replacement is apparently =org-re-reveal= [[https://gitlab.com/oer/org-re-reveal][here]].
#+BEGIN_SRC emacs-lisp
  (use-package htmlize)
#+END_SRC

*** Protocol

#+BEGIN_SRC emacs-lisp
  (require 'org-protocol)
#+END_SRC

In order to get Gnome to handle the URL correctly, save this to =~/.local/share/applications/org-protocol.desktop=.

#+BEGIN_SRC conf
  [Desktop Entry]
  Name=org-protocol
  Exec=emacsclient %u
  Type=Application
  Terminal=false
  Categories=System;
  MimeType=x-scheme-handler/org-protocol;
#+END_SRC

and run

#+BEGIN_SRC shell
  update-desktop-database ~/.local/share/applications/
#+END_SRC

Then use the following bookmarklet for capturing:

#+BEGIN_SRC fundamental
  javascript:location.href='org-protocol://capture://c/'+
        encodeURIComponent(location.href)+'/'+
        encodeURIComponent(document.title)+'/'+
        encodeURIComponent(window.getSelection())
#+END_SRC

Note the =/c/= in the URL, it denotes the capture template we want to use.

Further details are in [[https://orgmode.org/worg/org-contrib/org-protocol.html][the documentation]].

*** Ref

#+BEGIN_SRC emacs-lisp
  (use-package org-ref
    :custom
    (reftex-default-bibliography '("~/doc/lib/bib/main.bib"))
    (org-ref-default-bibliography '("~/doc/lib/bib/main.bib"))
    (org-ref-pdf-directory "~/doc/lib")
    (org-ref-bibliography-notes "~/doc/lib/notes.org")
    (bibtex-completion-pdf-open-function 'org-open-file)
    (org-ref-completion-library 'org-ref-ivy-cite))
#+END_SRC

** REST

Rest client with company backend & org support.

#+begin_src emacs-lisp
  (use-package restclient
    :mode "\\.rest$"
    :general (:keymaps 'restclient-mode :states 'normal :prefix ", ." :mode "\\.rest$"
                       "c" 'restclient-http-send-current
                       "r" 'restclient-http-send-current-raw
                       "v" 'restclient-http-send-current-stay-in-window
                       "n" 'restclient-jump-next
                       "p" 'restclient-jump-prev
                       "u" 'restclient-copy-curl-command
                       "N" 'restclient-narrow-to-current
                       "i" 'restclient-show-info))

  (use-package company-restclient
    :after (restclient)
    :config
    (add-to-list 'company-backends 'company-restclient))

  (use-package ob-restclient
    :after (restclient)
    :config
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((restclient . t))))
#+end_src
** Rust

Use =rust-analyzer=, as =rls= is somewhat obsolete.

#+BEGIN_SRC emacs-lisp
  (use-package rustic
    :mode "\\.rs$"
    :custom
    (rustic-format-trigger 'on-save)
    (rustic-lsp-server 'rust-analyzer)
    (lsp-rust-server 'rust-analyzer)
    (lsp-rust-analyzer-server-command '("~/.local/bin/rust-analyzer")))
#+END_SRC

** YAML
#+BEGIN_SRC emacs-lisp
  (use-package yaml-mode :mode "\\.ya?ml$")
#+END_SRC

